#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# parable
# Copyright (c) 2012-2016, Charles Childers
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# coding: utf-8

#
# Dependencies
#
import math
import random
import sys

#
# Memory Configuration
#

INITIAL_SLICES = 9250

#
# Constants for data types
#

TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800

# For precheck(), we also allow matching agains two "generic" types:

TYPE_ANY = 0
TYPE_ANY_PTR = 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Support code used later on

def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False


def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':
            braces = braces + 1
        if t == ']':
            braces = braces - 1
    if braces == 0:
        return True
    else:
        return False


def tokenize(str):
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned


def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Codes
#
# The Parable virtual machine is byte coded; each byte code corresponds to a
# single instruction. In this section we assign each byte code a symbolic
# name and value, provide an implementation for each (with one exception:
# see interpet() for details on this), and then build a dispatch table that
# maps each instuction to its handler.


# Constants for byte codes

BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66


# Implement the byte code functions

def bytecode_nop(opcode, offset, more):
    return


def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)


def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b + a, TYPE_NUMBER)
    elif precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = chr(int(stack_pop()))
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        a = chr(int(stack_pop()))
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_STRING)
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(string_to_slice(b + a), TYPE_REMARK)
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = request_slice()
        d = get_last_index(b) + get_last_index(a) + 1
        set_slice_last_index(c, d)
        memory_values[c] = memory_values[b] + memory_values[a]
        memory_types[c] = memory_types[b] + memory_types[a]
        stack_push(c, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_random(opcode, offset, more):
    stack_push(random.SystemRandom().random(), TYPE_NUMBER)


def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)


def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)


def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)


def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)


def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True


def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)


def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)


def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)


def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)


def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()


def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)


def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)


def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)


def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)


def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)


def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)


def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)


def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)


def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        s = int(stack_pop())
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, TYPE_POINTER)
    else:
        abort_run(opcode, offset)


def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)


def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)


def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)


def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)


def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)


def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)


def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)


# Create the dispatch table mapping byte code numbers to their implementations

bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Error logging

# Errors are stored in an array, with a couple of helper functions to record
# and clear them.
#
# The interface layer should provide access to the the log (displaying when
# appropriate).

errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Byte Code Interpreter
#
# This is the heart of the virtual machine: it's responsible for actually
# running the code stored in a slice.


current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.

should_abort = False        # Used to indicate if an error was detected during
                            # the current run.


def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag


# The interpret() function handles:
#
# - pushing values to the stack (based on stored type)
# - invoking the handler for each byte code
# - sets / clears the **current_slice** variable

def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Data Stack
#
# The data stack holds all non-permanent items. It's a basic, Forth-style
# last-in, first-out (LIFO) model. But it does track types as well as the raw
# values.

stack = []


def format_item(prefix, value):
    return  prefix + str(value)

def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r


def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r


def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]


def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)


def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Dictionary
#
# Like Forth, Parable uses a dictionary to map names to pointers. Ours consists
# of two arrays: one for the names and a second one for the pointers.

dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []

def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r


def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False


def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1


def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1


def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)


def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)


def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]


def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Memory
#
# Parable has a segmented memory model. Memory is divided into regions called
# slices. Each slice stores values, and has a shadow slice which stores the
# associated types.
#
# Parable implements this over several arrays:

memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice


def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    x = 0
    while x < 1250:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
#    if stack_depth() == 0:
#        collect_garbage()
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i


def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]



def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Garbage Collection
#
# Parable's memory model is flexible, but prone to wasting memory due to the
# existance of short-lived allocations. This isn't generally a problem, but
# it's useful to be able to reclaim memory if/when the memory space begins
# getting restricted.
#
# The solution to this is the garbage collector. It's a piece of code that
# scans memory for slices that aren't referenced, and reclaims them.

def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag


def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs


def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs


def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs


def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# The Compiler
#
# This is the core of the user-facing language. It takes a string, breaks it
# into tokens, then lays down code based on the prefix each token has.
#
# Prefixes are:
#
#   #   Numbers
#   $   Characters
#   &   Pointers
#   `   Bytecodes
#   '   Strings
#   "   Comments
#   |   Function Calls
#
# To aid in readability, the compiler also allows for use of number and
# functions calls without the prefixes.
#
# The bytecode forms are kept simple:
#
#   type           stored         type
#   ==========     ============================
#   Functions      pointer        function call
#   Strings        pointer        string
#   Numbers        VALUE          number
#   Characters     ASCII_VALUE    character
#   Pointers       pointer        pointer
#   Bytecodes      bytecode       bytecode
#   Comments       pointer        comment
#
# There are two special prefixes:
#
#   @<pointer>
#   !<pointer>
#
# These correspond to the following bytecode sequences:
#
#   &<pointer> #1 fetch
#   &<pointer> #1 store
#
# The compiler handle two implicit pieces of functionality: [ and ].
# These are used to begin and end quotations.
#
# Bytecodes get wrapped into named functions. At this point they are
# not inlined. This hurts performance, but makes the implementation
# much simpler.
#
# The compile_ functions take a parameter, a slice, and the current
# offset in that slice. They lay down the appropriate byte codes
# for the type of item they are compiling. When done, they return
# the new offset.


def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset


def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")


def compile(str, slice):
    global should_abort
    should_abort = False
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Final Bits
#
# A few things to help get the initial environment up and running.

def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line, request_slice()))


# some parts of the language (prefixes, brackets) are understood as part of
# the parser. but one important bit, the ability to give a name to an item,
# is not. this routine sets up an initial dictionary containing the *define*
# function. with this loaded, all else can be built.

def prepare_dictionary():
    """setup the initial dictionary"""
    s = request_slice()
    compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME), s)
    add_definition(':', s)
stdlib = "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57+/Xe9VVftd1dVfdUm/wJSByAvwJFT4Eiuv1CApprzXltea15r15n2T7MzMkkm9bAAMqjlU5zMzMnskzWvNXYAAHK1XOZmZkkk+uwAAOVzmZmZ77JN7AAAfVzfOZmZnvsk3sAAC6q7kkkkk3sAAC6prXmruSST2SZrXmrsAADlVzmZmZJJN/LAAA5Vc5mZmSSTez6qAAFcrfOZmZkkk3rYAAGa45pVV7K3z3n2Z3MkkkkgAAAAAAAAAACSSSSAANB8U9gABJJJJHOta81mv0nOXzXnmvPJJMzMzJJJvYAAF1V3JO615qSbkma15q7AAA5Vc5mZmSSTfywAAL1ze3MzMz3977VAAAfXveVzMzMn6Sb2AABdaq7kkkkk3sNGsrVeFa843vnMzMzJJmPNa1r5zgAAG6633v33330kky7AAA5Vc+799999mZk3sAAC6q7kkkkk3sAAKqyt+7ttN99pPnec7f13ckkkEGgAAAAdPAAAAAAAHZqSSSAAAOngJJJJIAAAZzL+aa5uLl3v3U00vru8u7u5JJvYAAF1V3JJJJJvYAAF1V3JJJJJmteauwBrQrm985mZmSST67AAA5Vc5999999mZmb2AABdVdySSSSb2AZrVVUiu0VRdq1V2d5zvd3d3MzMu9dtqqqkW1qqqyQu6vtve7u7uZmZd6qKrVLt3bVK1V9u+93d3czMzQhyuVCC6tqlUVVAb1vzt33v33330k+zLsAAa1qft6qu859z9+n79lUDzSNMIAAAAACSSSSA+qroegAAAAAABJJJJ8AAAW13W/aqVFe31V8qoAc5rWtGVQAVze+czMzJJJvYAAF1V3JJJJJvYAAF1W5JJ777JmteauwAAL+7d9+++++999mZdgAAcqvr+++++kmTew3VAAXVb1ckkkkm9gAAZze7zMzPffcm9gAGVRyqvMzM999yb2AABdVdySSSSZrXms5wAAD33zWvn580p7e1tJqS7v1huT0moAAACAAF1dAAAkkkqSAAAAAAAB6B8Tzdakk7PQNABEmivterm3KSavK3STWPQtAnOci/gTxt6bihVm7lF1et5r93Pvr/c++zMySfZl2AAByqu8zMySSb2GjwD79rt33uZnuSSTt2AABXnN75ySeySSd1dgAAcqucknskkm9gAAXVXckkkknfLsyqAAO71vfe5mTMkkzWvNfuc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AHKrnMzMyST7ewANGs5vfLzMzWSSc155ret+AAH3N75mZkySXN7AAAuqu5JOSSSqAAAZdbvMzMySTPvHmvNHl2ADWm/3bvv3333v0kmb2AABdVeZmZkklUAAB9e93kknvvvtUAABzM81dbryv1avzX6u/s/ZmYAABJJJJAD4egAAAAAAAAAACSSSSAADytVV1vM5+VrzX2vq+99++n30knvvvtUAABLa3u5mZmZn33316trzXl2AABWt65d8++++++kkzewAALqrzMzMkkqgAAPr3u8zMzJIAAATe97kkkkgAABVVJJJJJ995rzW9gAAXVfffffffST6qAAA3VZmZmZJJVAAAfXvd5mZmTMyqkkkqqkkkkk58ov5Re0qulBmVNVK/b3+9clT3nzgAAekkkVVVQAAAAAAAAAAAPAHQPHAdEkgAA/alVdNSckkwzMDzzWta1oADdVuSSSTMyvPPNb2AABV73eZmZkkn29gAAXVXmZmZJJVAAAfXvd5mZmSeoAABrdVuSSST1AAAN1W5JJJPc1rzysAAAuqvMzMyST7ewAALqrzMzMk9Q+8qq1r7e6341pre0WqQhV22VX139u7u7mfs8W1SLVKrQE33d5955rzzK7fAaSqnJ9799JJJJAAAAE1JJJOgAAAAAAAAAChJJJJAAAAANWmkl3uhJraTXvkvNblXzv797kmZkklUAABuq3JJiqvalTnNa1rVVet2qqAe5Kl6u1VQDSay+7727u7kk0mt1vYAABpNbrewAAF1JU5Kl6u1VQD3JUvV2qqffYJ+mprX32Znu98J935NgEBXkUFPwKwVAOQRUNSyKEIqB2Ar+5QgH7KBXICi/oov6AryKGEGQSEYhBEQ/RBQ/QC4xkYE/Uii/ogiP6Iaiiv6KL+goB+1SCbSpJJLMzMzMzAoAAIABJJJJAAAAAAAAAAAkkkkgAA5+qv2taqqzVBuKr6X9QKvIIrqOZ3P2fsz3veoS5vckkkgUk1tNcrnAJ9999m01iz2/eu7v7777SazmuckgSSaTVJb1vclgAC0mqT3rewFJJIrSa2mvszqf3ft5n0WYALSa9zXOBJ9999pNRZXd930Aknz0mi1SvmlulIosLg0QZGRhASSDAkVFO/d7737f0hJ3U9UAkN1gSTa7qEk3fw0kvuJprMzO5mZgAAAAHQDkkkaupJAAoAAAAA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JJL3gAAGpP1/v2d7J+/ft7gAAGZrfe5mZn79+3vAAAJXN8kknvv73Wv2teaea81zlAAASu9n6ffa++zMycv4AADtd7f376T333nmvLv0AAD9N/v057JX79+vcAAA1K5yTMnvvvt7gAAGa7vvczMz33339rXmuXgAAFX7etfua15qv3E8yZm8PQAP2ZmZmZmAAAAAAUAAAABdXQABKk7NSCvAAAHZKm5KnuSVGSpn6SrvdWvw92IAASTI1rzXeUAAB2u9z9mZkkn7zXn3efAAAZ7v337k++zckmdugAAOVzl5nuZmZmXvAAAPe77fcz9mZmZPda81y8AAA33fe5zMzJJL3gAAGuVzmZmZ77773zXmXgAAE3+v9+zvuZXvvvs3gAAHFcrzmZ7mZmZM81rzl0AAB613fe5n7MyST3WvNfd58AAB7vNXnPPPPPO+IsVD6KLWvrEQfoH6AAJ+ygyJ5BWIIEUWCoofoCgH36gUdKLBARuKi/oAqfoKL+iCGwVgqKn6IiKUosQP0VUWhhJQSTaNogBu7ZIQ2gCbu773vZ+/fpJJgAADgbAAH7MzMzMzAAACgJJJJIAAAADEk0nve1xJq7u40ljbTdU2m6TbbpZppptPTabpNpLJmZmZmABL7ygAAO13fc/ZmZmZP2tee95gAAafn79n73MzcknM8sABqd33uc9zMkkveAAAe933uZ3MySS94A1r5RrXa73777776STPNea5dAAAcrnMzMzJJPvda87z4AAD9X7f777377N5mTm8AAA5XOZnuT3332cugAAP2ft3+/ZnuZPffb3AACSTc929bBK2ij+UWJr3vtGxRcgMnvcIG6yEm9kJECSG7tySTaJJNpFf3VFpD9+/ftqK7FVii/v37Si/v379+/CSST8AAAAAAAAAAAAJJJJIAAAAAC2VUqrkqYux7VVVbdzx0++++++99999veAAAa5XOSST3333utecuAAAdrvZPZ9m5JObwAADzlc5me5mSSZ555rl0AAB73fe5nczJJPuX8AA5VDtb799999kkmcugAAOVzfMzMzMzJ+815y8AAA7Xe5nuZm5JM7dAAAcrnMz3MySS94AAB67vvcz9mZJJq/pJJJJJJJJBV1V2KH0RXZBVsjPyi0oKdgirztaUWIiEiRRZyAoHf1KK/oChtRYqLEAgIH79+tVdArBYosUQiix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RdIukWEX2HzkN8Rf0EQAQQRjx9nn7SfOvfO87+3f9m+Kk9J3zvr37en7Z183vPl2ybzJxMXccuquJ1zWuJK8YIgPl5/p6oxMYMbYk28P4COf2EXUkcKU264RcZtRLIsiyUjIuqFoqHEnzBPEU9kppT2KT3CmkHsDqJaFHIXIXVC1KOkWRf1kXakdEXUS5UsRaosi0loquUoyFHBFqA4RcRf1+vO0dpSke8Wf6OSTz9z/R/H+ldAALbbbaAAAAAAAAAAHZbbfttAAFttttAAAAAAFttttAAFttttAAAAAAFttttAAFttttAAAAAAAAAAC2222gAAAAAAAAAAAAAAAAAAAAAAAAAALbbbaAAAAAzMmZMzJmSABmTMkmTIAAAC2222gAC2222gAAAAAAAAABbbbbQAAAAAAAAAAttttoAAAAAAAAAAdltt+20AAW2220AAH/uAGgAttttoAAttttoAAAAAAttttoAAttttoAAAAAAAAAAW2220AAAAAAAAAAAAAAAAAADuSTkySTJJP6fJJtHyHdS5Rai/Isi4i0SyLIvIeof24dpI7h5DIuItC4iyLiLKR8hwA5D0i0O4doukXalU7h3DtF+h+o+w1B5VC91L2i6IuqkZFkXIn/MRu+63aLxVTIvculrGszWtmszNs7x1pzXJKS+Uikc721U3qa1M5VaqpLN8z0HfgAAAKqqqoAAC2/ZmSZJJMknPkzMkmZknyfJkzJJkye+899X2gAAAKoAACqqqqqqeamtS461erl2huIpNOtaF0ybVVd60KoxdLrQhrWhBdadaWMVFig6mppkWAL5CqW6Y21rY22bVyO9x125tbWm1rrW29866c7cccuXNZznNxzlzkdadGlNRNu9prToF3rSsd6NumCq5jm225uI8Kl3KbI2JtMzIWyO4Yi7c2m022xtWbYa2mG2bUY2ps22W1M2ZaZrW20tktWxzXDOc5ba5HORsxmN05xuc73M3bnMO2d648h99NJsPmad81rnNs0pvW9Jxm+a061zek1s+3N8dGjejjtda1oDTNaEd6IaE0jve2GtBo1p5rfA3xm974cR285zmtm9a245NuuOY2ttbYsmbOc499cnmvncVD9rWtahpgqfppVV5rUUVQZ2zNyPN43PHdw23d6dudeebt67uduMY/Otb1sUT7ehPt85pZrQpBdMNLvQLo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20AAAAAAW2220AAW2220AAAAAAW2220AAW2220AAAAAAAAAA/ZJDltttoAAAAAAeZJPMknmSTzJJ5kj7D7D7DsidkWijItEX2HlUu4b7D7D7D7D1DkOoeIvaLIsiyLRLItRZFpFkWqkfEWqF7hql0i9Q8hypekPcPBF0RYKPaVXUP7XKlVdQwJmZnstvv79d0AAAAAAAAAAABbbbbQAAAA8zMmZIySfMyZMkQ6h9h0KR/LUj+hkWRYqVolYpiphNiStErFJolalPPt9vt5z15znXXOQo2QzM2za2ReTQ2xqpHNCFZFqpVaFoAmRZBXnzznOc53zrrtVIedlaoRcKrSRjLEWkjKRpVWSefPOc5znfOuuUpylNKehswqeAVoirKmpTKnnzznfffXfr69iDzlW2vbrwq2zEVzUpyJWlTCaJXt9vOc653z19eqiV3EmRZF5chtlqUjkkZKKyLFCYiyLFFpI1IQEkkhA5zMzMud7ZAkkOMAVASATCBGQA5zM8e97PW5IAcWRgCqASAb3mW3t72khA5GAKkZIRXJTSTSmQDKDJTQsUjQspGhYku+/379+/ff3z59QV3NDbWCI/IsIu+/3fOc53zrruVRyU0StKalPTKbYYVXf7+P3v9KAnqHaP0Pfnff631/AAAAALbbbaAALbeZJLbaehbbbUOAAAAD5kk8mSSZm5JJmT+khMBTItEtQtVSGQ0ppTFVXnnOc5685zrrsCOSmiLw2WSqvfSLlQsixVVMiwi2CRaFlVDFMA9PTnOc53z19epVHmWUSu5LEWRaiyLEWRYpGCBGATnMzM97PW5IAScIMhIBN7zvvvvvrvrrulTzLKlOJK0gxFkWiqxFlFiLIspVtEC0plSmlNUKrz55znOc76lOd9+xJThU0qL0loSnELVJGhYItQsqRtSjIthVYiyLEoypklalVYTz55znOc75113RRcKekvEVKrwVMJhMA0g0gygxBrUppTSmlNSmVNEefPOc5znfOuu4qlcRZSMi1SLxNRIuUJCAAkCMhAIc57MzLne0kIHCCRfxhFfwUjFFlIyLIenpznOc756+vcp2JhNSnp4ytUq5JGIsiyLUWRZFhAjzme973s9b6SQJwhx+/Z9ogTR+0QhkzJ9ySe983d9XQAAAAFttttAAAAALbbbaAAAAHmZJJmbkyTP7JJFXd3eru0rCAjJBIQEEFU222mk4BFeZYRXKUxTSnnzznOc53zrqiDGEkktJKiCyAiyAjObu7u3aVEDCAiqbbbTSqAuZICLICJgDObu7u3Z2ZNySTJ3u7u7rTsyc4BR2ZOcttvtt7Mj5+zJmSTPPPB+UAAAAAttttoAAAABbbbbQAAAAySeSYBNEDV73v7ve97smQBfOowDnMzMzud7ssAVgwBV3u229ve7JSAze/ZmZmmkyAyEyFU223ppUQYwkklpJUQOJJ3u7u7rTsyb3u7u7rTsyc4BR2VLVV6jkqazI+SSpKqVJ5N75xUFUAAAAFttttAAAAAAALMkx8ABVVVVypUqSuVJNVKklUhs4AOShwBTbbenp0DkiaobbbTSogwkklwrsycA9V2ZOcAo7Mm5JO/cknm7u7+admTfvnm7u7607MnOAUdmTnEkktJKnMBriIIIBzABEEEb8Txl7vhoAAAAAAAAAAAAAAAALbbbbbuSSBOwBhIQLAOwDUgTFLKW6SSogcAVTbbaaVEDqm2200uzJ8A9HZk5wCjsyc4BR2YOAKptttNKgHJNU222mlURjCSSWrbshrVttvbbshrXfwQgSsAkgSZJJckl99/e7q6AAAAAAAAAAA9ySAC0AAAAAmSdkyZMknuATEAEQJUkt0klRA4Aqm2200qIN73d3d1p2ZOcAo7MnOAUdmb8vEASTiM5u7u71aVEDgCqbbbTSogdd3d3dadmTnAKOzJzgFHZnk+R+8669fslI942RdZRdYBV5375u76AAAAC2222gAAAAFttttAAAAAOzMmSAfgdmTckne7rbaaVEDqm2200quYCqbbb00qguAJmQqm229NJwBmZgKpttvTSogcAd7u7u607Mm97u7u607JnOAUdmTnAKOzN+Sb7kzJmZJzJJ+/fvu7t0AAAALbbbaAAAAAW2220AAAAA7JkkkA/A7JPvybkk883d2607Mm97u7u607knOAUdmTnAKOyDGEkktJKiBwBVNttppUQOqbbbTt3iyKQfaIGic573ve931uyGtW229tdzI/ZMkkzPv37Z9cegAAAAAAAAAAAttttoAAAAAySeZmTP0ASBEBhJbLdJJUQOAKptttNKiB97u7u607MnOAUdmTnAKOyT+klU223ppUQXAFU222mlRA6ptttM7MnOAUTJOzJ858Ao7MnPXf3z5rvdvjvXMZeZ55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kk8mT5555u7u7o7Mne9ADpDe9222227krhAnoBEgSwDUgT3333+/vf7+/gFttttAAAAAAAAAAAAAAAC5JPjgAdmTvegB/ZJPJk+eeebu7u6OzJ3vQA7Mne9ADsyd70AOzJ3vQA3JDJBOxtts229NJUQVVJJJJJVEMgJjOfN3d3Q7Mnz9/ZJM+z75u77u6AttttoAAAAttttoAAAAAFttttAAySfsgf0A3u3n1ttt2Q3vdttttvoBwPlVVV1999mZmZlt5xVVVVVXnOW222284qqqqqrw5y22297vaqqqqqt5y22223nFVVVVVec5bbbbbkA++VVVVVV1999mZmZlt5xVVVVVXnOW222284qqqqqrznLbbbbecVVVVVV/udMkhCegEYEkmST5mSZfL/fvf7+/v4AAAAAAAttttoAAAABbbbbQAA/smSSTnN3d3My284qqqqqrznLbbbbcgH3yqqqqquvvvszMzMtvOKqqqqq65zVttttvOKqqqqq85y22223gcVVVV5zlttttvOKqqqqq85y22223IB98qqqqqrr777MzMzLbziqqqqqvOcttttt5xVVVVVXnOW222284qqqqqr6AT+9IAAazJM+XJJbf7+/n9kkvz+PMkgPoAAAAAFttttAAAAALbbbaAAJkm5JP0AzRCEwgc3rM/ZmZbZziqqqqquuc1bbbbbkA++VVVVVV1999mZmZlt5xVVVVVXnOW222284qqqqqrznLbbbbecVVVVVV5zlttttvOKqqqinOctttttyAfH0VVVVXX332ZmZmW3nFVVVVVec5bbbawC3m1VVVVVTnOW222284qqqqqrz7Ofu88ECfud97+92+t73ve973toAAAAFtttQ4AAAAAAAAAe4A27ttttvOKqqqqq85y222230A++VVVVVV1999mZmZlt5xVVVVVX+PvvrfrbbbziqqqqqvOcttttt5xVVVVVXnOW222284qqqqqrznLbbbbcgH3yqqqqquvvvszMzMtvOKqqqqq85y22223nFVVVUV5zlttttvOKqqqqq30JM88/fu/d3dulttttAAAAALbbbaAAAAAAAEyQAEAA7kk8+fPiqqqqqc5y222230A++VVVVVV1999mZmZlt5xVVVVVXnOW222284qrhA1pVVV+++zMzLbbziqqqqqvOcttttt5xVVVVVX++++t+tttuQD75VVVVVXX332ZmZmW3nFVVVVVec5bbbbbziqqqqqvOcttttt5xVVVVVUwgTv79+zPszMLbbbaAAAAAW2220AAAAW2220AC2223CBPxANZmZ9mZlt5xVX7WlFn331ttttuQD75VVVVVXX332ZmZmW3nFVVVVVec5bbbbbziqqqqqvOcttttt5xVVVVVXnOW222284qqqqqrznLbbbbcgH3yqqqqquvvvszMzMtvOKqqqqq85y22223nFVVVVVec5bbbbbziqqqqqv8c/fvzz+/v3Pvvuf3Od190IEQgRIFkXcLiLlFkWRaFoW6RaRcItCzIvfrzt89IvSLpF8Yi91LqiwJkWkjUpNRfUXKkcRdQ5SRyVckjItJGhciqyLCVpTEGE8UpqU0o0Lgi8RcRdIusVVcRaoqMi1VJpI5EucIuSLcRYiyhchcUjlSyLEVoptSmKZSageEKcRai0LEXEWqiyLSRxFkXCL0i6oU6RaiIAQ3IE2QJqSE7AP7m+bNa59z9/W20AAAAAAAAAAAAAAAAC2222gAAAW2220AAAAAAAAAALbbbaAALbbbaAAAAAAAAAAFttttAAAAAAAAAAC2222gAAAAAAAAAB2W237bQABbbbbQAAAAABbbbbQABbbbbQAAAAABbbbbQABbbbbQAAAAAAAAAAttttoAAAAAAAAAAAAAAAAAAAAAAAAAAC3/FttumgAAAAAAAAAW2220AAW2220AAAAAAAAAALbbbaAAAAAABbbbbQALbbbaAAAAAAAAAAHZ+5JkmJMkknUPsPUNDqlHqHkOKqMReyLQ5DuHSLxSPSL2i9w7IvUPkPsPEl1Rfal7pJqSVJWVJUrUlVKk1zzYedVQAAFAAAAAAAAAAAW2220AAA/ZINt5bbbbziqqqqqvOcttttt5xVVVVVXnOW222284qqqqqrznLbbbbfQD75WIxVdfffZmZmZbecVVVVVVv3327bbbbYB98qqqqqrr777dtttt5xVVVVVXnOW222284qqqqqrznLbbbbcgH3yqqqqquvvvszMzMtvOKqqqqq9wJJlySXJJ7fl33ffd07kkA/AAAAAAAAAAAAW2220AAAmSbkk3ALvWbzMzMttgH3yqqqqquvvvt22223nFVVVVVec5bbbbbziqqqqqvOcttttuQDnFVVVVVdZ99rMzMzLd7VVVVVV7zl3bbbb2Ac4qiqqquucu7bbbd7VVVVVVpzmrbbbbvaqqqqqu92222272qqqqqrvdttttuQDnFVVVVfnz5zvnnfv7z7u7v71oAAAAAAttttoAAAABbbbUOAAAGSSzJOcdBbewDnFVVVVVdc5d222272qqqqqrvdttttu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqr3nLu2223IBYB98qqqqqrvf32bzMzMt3tVVVVVXe7bbbbrSqqrhA1pVXOOZmZlt1pwgM0qqq95mbzMy23sA5xVVVVVXRvm3V4LbbbaAAAAAW2220AAAAAttttoFtttv0Att5S2222272qqqqqrvdttttu9qqqqqq73bbbbbkA5xVVVVVXXOZmZmZlu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrvdttttu9qqqqqq95y7tttt3tVVVVVXe7bbbbd7VVVVVV3u2223uQDe1VVVVF1vPvPu7u7q222gAAAAFttttAAAAALbbbaAAAfZkk+B9C/OT5nz58+fPnxVbu2223utKqqqqq/15d22291pVVVVVW7ttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMtvOKqqqqq85y22223nFVVVVVb999u2223e1VVVVVd7ttttt3tVVVVVXe7bbb3uqqqqqqrP07PmecH0FttttAAAAC2222gAAAAAKqqqqoAAHlSTSu1ULda1rWtKqqr3nLu2297/QDdVVVVVV1zl3bbaW5AOcVVVVVHXOZmZmZ3usVVVVVV3u22297qqqqqqq6N222291pVVVVVX+3bu2223sA5xVVVVVXXOXdtttu9qqqqqq73bbbbbkA5xVVVVVXXOZmZmZlu9qqqqqq/z9AOfNv63+ttttvYSPgAAAAAAAAAAAAAAAFttpAyAWAZANuszMzMt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd7ttt73t2qqqqqq95y75ALbbbkAsAvyqqqoo6399nMzMuW62qqqqqu92222272qqqqqrvdttttu9qqqqrzWl5y22223e1VVVVVd7ttttt3tVVVVVXmf3379mt5n7L3O9ttttttttttoAAAAAAAALbbbaAAAA9ySfDoW272qqqqqrvdttttuQDnFVVVVVdc5mZmZmW72qqq4QNaVV5zMzMy23e1VVVVVd7ttttt3tVVVVVXe7bb3ve72qqqqqrectttve72qqqqqrvfe973ve93tVYjFd773ve973u9qqqqqq733ve9ttu9q7bbbbbbb599/kX8giyLEWRnyZJlv7+/vf7+/rf4AAAABbbbbQAAAAC2222gAAAGSTZmTJOc3d3d3T0A5xVVVVVXXOZmZmZlu9qqqqqqu92229tu9qqqqqq73bbbbbvaqqqqqu92222272qqqqqrvdtve973IBziqqqqqus++zMzMzvd7VVVVVV3vve973ve72qqqqqrvfe97S2272qqqqqrvdtve973e1VRVVV16ATwQJ39y7vszO99bbQAAAC2222gAAAAFttttAAAArAPoBq237ve97kA5xVVVVVXXOW25mZbvaqqqqqu92222272qqqqqrvdttttu9qqqqqq73bbbbbvaqqqqquEDnMzMzMy3IBziqq6IGtKqrqQOczMzMzLd7VVXCBrSqq6IHOZmZmZlu9qqqqqq73bbbbbvaqqqqqu923ve973e1VVVVVaprb+7/b+53++/PN6kJJJqATIvRFj5Cyi8869dIvPJF6hapH30pHEXyGSE95Kr5DEofKl4Iu4fofEXSpeJRyGqoXKlqkaixLYi4i0EvsOQ0PcP3kND9D7Dn2H6H2H2Ghx9h9pJ3nHooAAAAAAW2220APuSQPAAAAAAAACZIAAAAAAAPMkgPoAAAAAAALffffffVoAAAAAdySAfgAAC2222gAC2222gAAAAcySAPeZJAHoAAFttttAAAAAAAAAAD5kktttvtAAAAAAAAAADsttv22gABkkAAAAAAAAttttoAAttttoD3JIcAJkgAAAttttoAAttttoAAAAAAC5JHwAABbbbbQAAAAAAAAAAB7kkOAAAH+ABoAAAAAAAAAFttttA/ZJB0AAAAAAA+5JA8BbbbbQABbbbbQAAAAAAAAAAttttoAAAAAAAAAAeZJPMknmSTzJJ7kk+5JGST7DqHJUX2H2H2H2H1D7DyHpUL1DRI9w9Iuoe6DuHIdEnyGh2i+Q9kPSqTVLBL6i0kc/ioXUMSZknvzJkyTO5klvu+27sOAAAAAAAAAAAALbbbaAAAA/ZJPk/YBkgQmszP2Zmd7SEAOcVVVVVV1P8AyB99mZ73vet3tVVVVVXe7bbbbd7VBVVXe7bbbbd7VVVVVV3u22223e1VVVVVd7tttttyAc4qqqqqrrnMzMzMy3e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVfffvvuSTnt/fv3620AO5JAPwAAAAAAAAAAAAAABMk3JJ83d3dzMtyAc4qqqqqrrnMy2297vaqqqqquc5bbbe93tVVVVVXe+973ve97vaqqqqqO9973vf7ve6NjFVVXe+9ttttyAc4qqqqqrrnMzMzMy3e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVXCBrXPuf33P1v17/XvctttttAAC2222gAAAAAAAAAAAXIDdW2223IBziqqqqquucy223vd7VVVVVVznLbbb3u9qqqqqq733ve973vd7VVVVVV3vtLbbbd7VVVVVV3u973ve97vaqqqqqu9973ve973e1VVVVV3vttt7bd7VVVVVV3u22223e1VVVVVd7tttttyAc4qqqqqrrEhIQmkhJJ9++bu7u6AAAAC2222gAAAAFttttABbbbbbbbbbcIEczMzMzLd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbd7VVVVVV3u22223e1VVVVVd773ve973u9qqqqqq3nLbbb3uQDnFVVVVVdc5mZmZmW72qqqqqrvdttttu9qqqqqLvdttttujaqqqquEJJAPECJAkk4hIQH5973ve96220AADmSQF/W220AAAAAttttoAAAW2222AfoAwDTbfrbbd7VVVVVV3u22223e1VVVVVd7ttttt3tVVVVVXe7bbbbcgHOKqqqqq65zMzMzMt3tVVVVVXe7bbbbd7Vea0qqqrzlttttvCBzmprSqqqqry22973t3tVVVVVXW7bbbe3e1VVVVVd22297272qqqqqro/OBAniBP2/e9/e971ttttttttoALbbahwAAAAAAAAAAAH9MmZI22229ze1VVVVVd7ttttt3tX58+fM+T5negUdmTnAKOzJzgFHZnfnz5negUdmTnAKNySeTJ85u7u7d12ZOcAo7MnwD0dmR9ySeedD2gALbfckl+W0BbbbbQAAAAAAAAAAAPmST5kk3Mkk/pkmcl3d3d3aVEEpJJcJKiCUkkuElcAZIPne7u7utO5JzgFHZk5wCjsyO9BVvZk5wCjuzJPmSd7u7u7dOkGMJJJaSVEFZzW7uIgjPF3fFt2kkkkgAAC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lSBEgTkAu++de+t176RekXyGUo9EXEWRcSXEWOVIyosiyi6RZFxFkWqWRdEWSq0L3DklHRSOkXaLIupI6KLiLgi1C3EWUjCLIukXVSxFxSOIuIsi5SKyLcUjkpHOofefJynt/AAAttttoAAttttoAAAAAAttttoAAttttoAAAAAAAAAAW2220AAAAAAAAAAAAAAAAAAAAAAAAAABbbbbQAAAAAAAAAAt999999WgAW2220AAAAAAAAAALbbbaAAAAAAAAAAFttttAAAAAAAAAADsttv22gAC2222gAAAAAC2222gAC2222gAAAAAC2222gAC2222gAAf4AGgAAAAAttttoAAAAAAAAAAAAAADuSQD8AAAAAAA+5JA8AABbbbbQAAAAAAAAAAttttoAPv379krEWh5QZSOQ7ReIsIvcMi6hdovpA1Sk+5JP0mSZ/TJMc76vt3QAC2222gAAAAAAAAAAAFttttEyRkk/xCBPSQihIqqoCg7373vf0971v0MtbG1Nqmw2qNYVtWaA2s21bG1mRmkm1GyGxMabLGm2ybGzGa21U7IJqILEYKIqKIxVYiIqKwRRVFYoskQSRQFggwUjEWIiLEVRic5mZmZne6Ia13vMkltvn8dzJzgFHZk5wCjsyc4BR2ZOcAo7MnOB+ySHB3Mnneg9Wsyc4AtZn98/pknyeeO+5JPPP7+/f397f4AAttttsyQA7kkA/AAAttttoAAAABbbbbR8ySfMknMkm5JPckKbeW29aUAMgmqbbbQ0qgMYSSSWtJk5wBamTnAKOzJzgFG5JPJk+d7u7u607MnOAUdmTnAKOzJzgFHZk7+t232G+c5a/W6AAW2220AAAAAttttoAAAABbbbbRMgIsgIkICHAFXi7u7u0nAGSCap7u7rTsyc4D229mR3oKt7MnOW21R2ZOcAo7MnOAUbkk8mT4883u7utLkk8mT53roUdmTnAKOzI2ZkyTzzu7u60AAtttqHAAAAAAAAAAAAFttttH9Mkz9kk5u7v3d3Tsyc4BR2ZOcAo/sknkyfO93d3dafMknZk+TgX229mR3oKt7Ml2AHQMqrsAOgZKl2AKK+qkm5U+d7u7u607Mn7vR9KAALbbbaAAAAAAAAAAAAAALkk2SZCMOm222lRBjCSSWklQMgJIqm229admTnAKOzJzgt9tu5JPJk+b55u769Po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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(tag[2], TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        slice = request_slice()
        interpret(compile(src, slice), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and l != '````\n':
            s.append(l)
        elif l == '````\n' and fence == True:
            fence = False
        elif l == '````\n' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
            except:
                e = sys.exc_info()[0]
                if e == SystemExit: exit()
                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s, request_slice()))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)


def interactive():
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

