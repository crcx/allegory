#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# Parable, Copyright (c) 2012-2016 Charles Childers
# coding: utf-8
INITIAL_SLICES = 9250
PREALLOCATE = 1250
import math

try:
    import random
except:
    import os
TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800
TYPE_ANY = 0
TYPE_ANY_PTR = 1
BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66
def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False
def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False
def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned
def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r
should_abort = False        # Used to indicate if an error was detected during
                            # the current run.

def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag
def bytecode_nop(opcode, offset, more):
    return
def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)
def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--

def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)
def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_random(opcode, offset, more):
    try:
        stack_push(random.SystemRandom().random(), TYPE_NUMBER)
    except:
        rand = (int.from_bytes(os.urandom(7), 'big') >> 3) / (1 << 53)
        stack_push(rand, TYPE_NUMBER)
def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        i = stack_pop()
        if i > 0:
            stack_push(math.sqrt(i), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)
def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)
def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True
def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)
def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)
def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)
def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()
def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)
def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)
def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)
def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)
def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)
def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)
def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)
def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)
def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)
def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)
def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)
bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}
errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)
current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.
def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if math.isnan(opcode):
                opcode == BC_NOP
            else:
                opcode = int(opcode)
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0
stack = []
def format_item(prefix, value):
    return  prefix + str(value)


def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r
def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r
def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]
def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()
def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]
def tos():
    return stack_depth() - 1
def stack_type():
    return stack_type_for(tos())
def stack_swap():
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)
def stack_dup():
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING or at == TYPE_REMARK:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)
def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)
type_converters = {
    TYPE_BYTECODE:   convert_to_bytecode,
    TYPE_NUMBER:     convert_to_number,
    TYPE_STRING:     convert_to_string,
    TYPE_CHARACTER:  convert_to_character,
    TYPE_FLAG:       convert_to_flag,
    TYPE_POINTER:    convert_to_pointer,
    TYPE_FUNCALL:    convert_to_funcall
}

def stack_change_type(desired):
    original = stack_type()
    if int(desired) in type_converters:
        type_converters[int(desired)](original)
    else:
        a = stack_pop()
        stack_push(a, desired)
dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []
def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r
def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False
def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1
def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1
def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)
def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)
def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]
def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''
memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice
def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if stack_depth() == 0:
        collect_garbage()
    x = 0
    while x < PREALLOCATE:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i
def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]
def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size
def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
#        memory_values[s] = list(map(lambda x: ord(x.encode('utf-8')), list(string)))
#        memory_size[s] = len(memory_values[s])
    else:
        set_slice_last_index(s, -1)
    return s
def slice_to_string(slice):
    """convert a slice into a string"""
    return ''.join(map(lambda x: chr(int(x)), memory_values[slice]))
def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag
def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs
def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs
def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs
def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1
def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")
def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset
def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset
def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset
def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice
def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))
def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib = "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AAAAeSpNWvq8eqqqu5KmpUnvns1OMqTzepua1qqqVNTfe96HOd++PQVUAPffEFSCpBUgqQVDKLtIKkFSCshy75zMzM73ve5rWEFSCpBUgqQVIKkFSCpBUhy75zMzM++++zWsIKkFSCpBUgqQVIKkFSCpDKq75zMzM++92iB2pm92QVupLtIKkFSCpBUgqQVIKkMu+czMzPvvvsNawgqQVIKkFSCpBUgqQVIKkMu+czMzPvvvs1rCCpBUgqQVIKkFSXdtgXaQVkMu+czMzO973ua1hBUgrIKkFSCpBUgqQVIKkOXfOZmZne973NawgqQVIKkFSCpBUgqQVIKyHLvnMzMzve+PeSB3Oc0QVIKwurtIKkFSCpBUgqQVIa0MAP29/v2fZmd73vc7veEFSCpBUgqQVIKkFSCpBUhW3vs4QkmzZxUKlBiqver51H5YAANLlVUAABVVAJJJJIAAAAAAAAAEne9793SQSSTdfvuHmd371lSeVUmD7ZzN96/CqqgB9l3kgqQVIKkFSCpBUgqQVLol2yH67/fs+zM73ve/ZveEFSCpBUgqQVIKkFSCpBUh+u/37PszO973ua1hBUgqQVIKkFSCpBUgqQVIcu+czMzO9973rkD9nOaIKkFT7Gc5xjGcgYP2c/v3vev073vu4+xhdAAAOM85f67ub73t3sAAD37Wuc933vSSTvqoAADmd65y93dySS97AAA9xrXOe973rkv9d6x9j73OAAAa+x9jH7Wuc933vSTknqoAxjGMYxjGHrlzfPqm/jf33ru1QA5UqqA0vDy6u7E3OzUkgCSSfSQCQAAAAADMzMzMzMAVYuTEPe9v3kFQAuT0qTza4qpPbv9+/c727u7u7uSSe3sAAD161znq973pJNaLzkAArWtVV3d3ckmtADDHwYX9j6s6qru7uSSXj7GN438GHz4zlnGaZqru7uTvfe394AAxnmtc573vek73MAAAvFa1VXd3cne5gAX9nOc5DOPvq1qqu7u5O9zLzkAAMYzTWqq7u7uXiTOPvsasAADP2K1qqu7u5O99qwAAPZx9999vWalVWakxOXyVj2+8793775QAgAqqgEkkASSSTqSSSAAAAACSSSSAACSXUnkkg8poAz2VJ3sqRlVM+68fe9dt5u7u7tTuYAABeK1qqu7u5O9zAL+znMy7sisupd3d3VMgcu+czMzO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KqrIquGu+87lVV1VVVV0557JM2SSSACSSSSAAAJMzuruqvur6q7qrvMzE999zM7JJFVUiqqMiqsiKrmZmZmZmZhEmlVUVXe4SEh5oACQnNySZqSSSACSSSSAAAe73ve2SQgGEYEhDve697MzMzMzMzCfCaVVRVczMzMzMzMzMzEjIquOlV8sgSftEAho0SSQk7ze927vd73ve98AJJJJIAAAkzPKv9d1V3bfebzMzMzMzM6RVVVVzMzMzMzMzMzMZJ9olttqqr5uSSSfakhJDRNbJ0YPpJJJoBJJJFnYAB73vd7171Ik6TWghJXe997MzMzMzMz4Te1VVVzMzMzMzMzMzMSKqqqry87t3V3dX355u7u4kkkgAkkkkgAACTM5VXyr8qquqz9+xPVXznOc95zivSKqqquZmZmZmZmZmZiRVVV3vd6Pma+Pn5r3uYltlySGySCEkGSCoWyVYWKMLIWUwsLULrddOu87F59/QvouxfrC+i0L/U/7vn5YXkLJVheQuRVwWF06qVwWQlzoW/p+nPBbKeQso4wq1qpyqaC5MKuVTk5QswuULC86ru7uv05xv3MAAAAAAASSSSQAAJJJJIAAAAAAATqZKrMziTJ6HgAEkkkkAADySTySQAAAAAAAAAAAAAAAAAAAAAAAASSSSQAAJJJJIAAEkkkkAADMzMzMAAAkkkkgAASSSSQAAEkkkkAACSSSSAAAzMzMzAAAGZmZmYAHXXXXXXXXTq5l1U4qYqapqHZaHJhcngvRdzydzXcLk+zgvs9ns/TqfYXSVfXgurl84ke/f2chiSSSACSSSSAAA667duefNeSp0vX66sjZiqapibBFUtkWylL+/vf73+9+WmzbaSELbbczMzEiqqqrmZme++++4GZmZiRVczMzDzYSEDi+rv77e973vfOc5zgAAAABJJP1VVXV+1fVBA3vfvOGZmZhmZmdJmZmZmZmIZmZnvvvvuGZmYyZmZimlVZPLAJA7ze9u+b33gAAAASSSTEkkxmeVflt9577777hmZmdJmZmY/Grbb77777QhdSGtGtAKr77777g6JFVqqr55zoHxPuEiQAAAAbV7ugTNm973ed3vRNE3ub33nuamZme5mZmBuR0q+rpV9DMzM+MzMz33332kyqqqq7+++9/fqu7rq/N3d3ZNAAAAAHOc5ve973ve+b3slJrfm97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CqyLVQZKaCtUGlNKaCZFpFkWkW2ytqbbZq2Ns21DaEttqGxttbataYsYogLIwYkWCKooqiyK22hbbbVsZU2bJCtio2igrItVCsi1UhkWFVoWRaRahZFkWRaFVkWUWRaFVsEGKYlNKaU0pqg0phVaRbYVWRYVWRaRZFhVZFkWRakWRZFkWSqyLBaRaRZFkWosRbbbJrbZprbW2WZrbWWabVsDWSNiG1sBRSKqyEVZBSCxQVVIpNY21imxtsJtasUbEW0ptQrSmgLFMqYZtKMi0RVtVRFkWQitlQZFohGRZFqLUiyLFVGRapViFaRG21bSmzbbbatrYvGkTjJDaibbRNotqFVZFi2klbQgyLFKUyLVFDSmhQ0pkihpTUqMUxUGSmimSmktpCRZIc5znObCBN73ve9w4isVRBQ1qSAW22shCKqsgEutGia1q222qq5mZmZmZmMiquvfe+k6Syd0u934GHYsAAAAADe973snCa5znvMzMzMzMzMzMzOyKq5mZmYBmZmZmZmZmZmMiqueeebDXNkA5+5zhrQCSSSSAAAACb3vf3wTpNSa73v32ZmZmZnvuZmZjJmYrmZmZmZmZmZmZmZmYyKq4zs91rXxNE7nOcxJ8PPQ8CSSAAAAHN73veidJ4RJ4HOc973pFVUFVczMzLIqrmZmZmZmZSKqqqtk2W2215N327uv379V/eefffT75v3QAkkkkAAAAEkk2g3ffffffc5znOc2pbbbdyb3ve972qqqqqqqqq7JeZmZmZd66v7d3d3T4AkkkkgAAAAA+63d3d2rzMzMzKzMy2qqu5Lbbaqq7Jbbbem973ve9q85zi7zMzMzr7l51mZzG/S3QHJO5JJAAAABJJN+2r+2r898+8+59znFVVVVVdyW221VVVVVVV5znOcy7zMzMz2vOvyrz9nucz74ASSSSQAAAASSTKuVffXchznOKqqvSS2222S222uZmYqq4kVXBVWyKq3P3m9HSdJz885vm985znOc4AAAAAASSTa7q+qnhOa5zne5mZmYkVXBVWyKq0VVzMzMVVaqqyUttbvvd90kcJ9mffffR9W/dgAACSSSSAA5zm973vv1J8T3777PszMzMzMzMzMxdyW221VVsltttVVVVWyW22379+/P33vuPK857q+t8t9y7fdZfefue8mt/ueNtefs/a/PYU+C0LzC4LgtwKYWKPLC+ahdC/C4LuF18+/fO69z9b5vRJCyQcP0kGg6PxCAPrJIB2LQX6ppC41CwsoZKtC1TUkYWkqwsLC0JWFhYWRVy1CfTytV9uv36M5ISSSSQAAAAAAAAASSSSQAAHkknkkgAAAzMzMzAAAJJJJIAAEkkkkAAAAAAAAAAAAAAAAAAAAAAAAAAAABJJJJAAAAAAAJJJJIAAAAAAASSSSQAAAAAAAAAAATMzMzEAABMzMzMQA/fv379+/fv3y884L6LCwsLC8nk5QuqTCwsLQsLC8mn2dpV3Op1Ov6YXs1O4XlTLV1dVXV1VVdKnKnaTTdAAAEkkkkAAJJJt1X3VX1111fVdV1VddaNjZmmWs20ts1bGaZjam0WtMxWocd+/fv48crsK02a2UEWZWbYEa22sWsNaDWpA1qG973ve0BVVVVsltttVVVVVVVVVbJbbbdCq4/ffcAAAAAAAJJJvCea5zneqqqqqqq2S222qqqqqqqqqtktttuU3v9ve9773nOc4cAAAAAAAA5VwnCcJ75+/e84qqqqqqr2S2224R0quOlVVVVVWyfb3ve972+4+yQ3d3XV3ddVdWq/qvrZzPqt988AAAAAAAADqr+vur6qqu713ve96qqqqqqrScNfc5znOc4BbbbaQttttIW222kLbbbwmyGuc5znBV1uvvPP313ddeVf7777777NgAAAAAAAA+/Vfe7u7uVLvqqqSSSZV1mZmZmVdZmZmZKuVddfAFQttttIW222kLbbbSFttt4TZDXXXXXXXXXVPHcR3qYUowvHjx48ePHjv8JJJJIAAAAAA5z4n01AANk2TwkkPfvvl+6QttttIW222kLbbbsmyGuc5znOc4QttttIXMzMzKuszMzMyrrMzMzFXKuugBd9/p01rVOccSGyFhYrv37+ffnt38eBJJJJAAAAAADnZIBrve973hC2220hbbbaQtttuybIa+5znOc5whbbbaQttttIW222krMzMzFXKuupJJJKul3dd1fV3ddaBn2iSSSSAAAAAAOc9JScJz3zz9zjshbbbaQttttIW2234myGt73ve97IW222kLbbbSFtttpC2220hbbbdkwmyGvLcPpIe/E++sn32z67AAAAAAAADqr6q9rKvqr2r2r87733dVdZmZmZ4SkNW+W20hbbbaQttttmwNE1Jrckkkq5dV1JJJJ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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=True

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        clean = l.strip()
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and clean != '````':
            s.append(l)
        elif clean == '````' and fence == True:
            fence = False
        elif clean == '````' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()

