#!/usr/bin/env pypy3
# Copyright (c)2012-2016, Charles Childers
# Parable, Copyright (c) 2012-2016 Charles Childers
# coding: utf-8
INITIAL_SLICES = 9250
PREALLOCATE = 1250
import math

try:
    import random
except:
    import os
TYPE_NUMBER = 100
TYPE_STRING = 200
TYPE_CHARACTER = 300
TYPE_POINTER = 400
TYPE_FLAG = 500
TYPE_BYTECODE = 600
TYPE_REMARK = 700
TYPE_FUNCALL = 800
TYPE_ANY = 0
TYPE_ANY_PTR = 1
BC_NOP = 0
BC_SET_TYPE = 1
BC_GET_TYPE = 2
BC_ADD = 3
BC_SUBTRACT = 4
BC_MULTIPLY = 5
BC_DIVIDE = 6
BC_REMAINDER = 7
BC_POW = 8
BC_LOGN = 9
BC_BITWISE_SHIFT = 10
BC_BITWISE_AND = 11
BC_BITWISE_OR = 12
BC_BITWISE_XOR = 13
BC_RANDOM = 14
BC_SQRT = 15
BC_COMPARE_LT = 16
BC_COMPARE_GT = 17
BC_COMPARE_LTEQ = 18
BC_COMPARE_GTEQ = 19
BC_COMPARE_EQ = 20
BC_COMPARE_NEQ = 21
BC_FLOW_IF = 22
BC_FLOW_WHILE = 23
BC_FLOW_UNTIL = 24
BC_FLOW_TIMES = 25
BC_FLOW_CALL = 26
BC_FLOW_DIP = 27
BC_FLOW_SIP = 28
BC_FLOW_BI = 29
BC_FLOW_TRI = 30
BC_FLOW_ABORT = 31
BC_MEM_COPY = 32
BC_MEM_FETCH = 33
BC_MEM_STORE = 34
BC_MEM_REQUEST = 35
BC_MEM_RELEASE = 36
BC_MEM_COLLECT = 37
BC_MEM_GET_LAST = 38
BC_MEM_SET_LAST = 39
BC_MEM_SET_TYPE = 40
BC_MEM_GET_TYPE = 41
BC_STACK_DUP = 42
BC_STACK_DROP = 43
BC_STACK_SWAP = 44
BC_STACK_DEPTH = 45
BC_QUOTE_NAME = 46
BC_FUNCTION_HIDE = 47
BC_STRING_SEEK = 48
BC_SLICE_SUBSLICE = 49
BC_STRING_NUMERIC = 50
BC_SLICE_REVERSE = 51
BC_TO_LOWER = 52
BC_TO_UPPER = 53
BC_REPORT = 54
BC_VM_NAMES = 55
BC_VM_SLICES = 56
BC_TRIG_SIN = 57
BC_TRIG_COS = 58
BC_TRIG_TAN = 59
BC_TRIG_ASIN = 60
BC_TRIG_ACOS = 61
BC_TRIG_ATAN = 62
BC_TRIG_ATAN2 = 63
BC_VM_MEM_MAP = 64
BC_VM_MEM_SIZES = 65
BC_VM_MEM_ALLOC = 66
def is_number(s):
    """return True if s is a number, or False otherwise"""
    try:
        float(s)
        return True
    except ValueError:
        return False
def is_balanced(tokens):
    braces = 0
    for t in tokens:
        if t == '[':  braces = braces + 1
        if t == ']':  braces = braces - 1
    if braces == 0:
        return True
    else:
        return False
def tokenize(str):
    tokens = ' '.join(str.strip().split()).split(' ')
    cleaned = []
    i = 0
    while i < len(tokens):
        current = tokens[i]
        prefix = tokens[i][:1]
        s = ""
        if prefix == '"':
            i, s = parse_string(tokens, i, len(tokens), '"')
        elif prefix == "'":
            i, s = parse_string(tokens, i, len(tokens), '\'')
        if s != "":
            cleaned.append(s)
        elif current != '':
            cleaned.append(current)
        i = i + 1
    return cleaned
def condense_lines(code):
    """Take an array of code, join lines ending with a \, and return"""
    """the new array"""
    s = ''
    r = []
    for line in code:
        if line.endswith(' \\\n'):
            s = s + ' ' + line[:-2].strip()
        else:
            s = s + ' ' + line.strip()
        if is_balanced(tokenize(s)):
            r.append(s.strip())
            s = ''
    return r
should_abort = False        # Used to indicate if an error was detected during
                            # the current run.

def abort_run(opcode, offset):
    global should_abort
    report("E05: Invalid Types or Stack Underflow")
    report("Error processing `{0} at offset {1} in slice {2}".format(opcode, offset, current_slice))
    should_abort = True


def precheck(req):
    flag = True
    if stack_depth() < len(req):
        flag = False
    i = stack_depth() - 1
    if flag:
        for t in reversed(req):
            if t == TYPE_ANY_PTR:
                if stack_type_for(i) != TYPE_POINTER and \
                   stack_type_for(i) != TYPE_STRING and \
                   stack_type_for(i) != TYPE_REMARK and \
                   stack_type_for(i) != TYPE_FUNCALL:
                    flag = False
            elif t != stack_type_for(i) and t != TYPE_ANY:
                flag = False
            i = i - 1
    return flag
def bytecode_nop(opcode, offset, more):
    return
def bytecode_set_type(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_NUMBER]):
        a = stack_pop()
        stack_change_type(a)
    else:
        abort_run(opcode, offset)
def bytecode_get_type(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_push(stack_type(), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
# --[ Factor out specific conversions for BC_ADD ]--

def bytecode_add_NN():
    a = stack_pop()
    b = stack_pop()
    stack_push(b + a, TYPE_NUMBER)

def bytecode_add_SS():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CC():
    a = chr(int(stack_pop()))
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_CS():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_SC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_STRING)

def bytecode_add_RR():
    a = slice_to_string(stack_pop())
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_PP():
    a = stack_pop()
    b = stack_pop()
    c = request_slice()
    d = get_last_index(b) + get_last_index(a) + 1
    set_slice_last_index(c, d)
    memory_values[c] = memory_values[b] + memory_values[a]
    memory_types[c] = memory_types[b] + memory_types[a]
    stack_push(c, TYPE_POINTER)

def bytecode_add_CR():
    a = slice_to_string(stack_pop())
    b = chr(int(stack_pop()))
    stack_push(string_to_slice(b + a), TYPE_REMARK)

def bytecode_add_RC():
    a = chr(int(stack_pop()))
    b = slice_to_string(stack_pop())
    stack_push(string_to_slice(b + a), TYPE_REMARK)

# --[ Finished specific conversions for BC_ADD ]--

def bytecode_add(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        bytecode_add_NN()
    elif precheck([TYPE_STRING, TYPE_STRING]):
        bytecode_add_SS()
    elif precheck([TYPE_CHARACTER, TYPE_CHARACTER]):
        bytecode_add_CC()
    elif precheck([TYPE_CHARACTER, TYPE_STRING]):
        bytecode_add_CS()
    elif precheck([TYPE_STRING, TYPE_CHARACTER]):
        bytecode_add_SC()
    elif precheck([TYPE_REMARK, TYPE_REMARK]):
        bytecode_add_RR()
    elif precheck([TYPE_POINTER, TYPE_POINTER]):
        bytecode_add_PP()
    elif precheck([TYPE_CHARACTER, TYPE_REMARK]):
        bytecode_add_CR()
    elif precheck([TYPE_REMARK, TYPE_CHARACTER]):
        bytecode_add_RC()
    else:
        abort_run(opcode, offset)
def bytecode_subtract(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b - a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_multiply(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(b * a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_divide(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b / a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_remainder(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        try:
            stack_push(float(b % a), TYPE_NUMBER)
        except:
            stack_push(float('nan'), TYPE_NUMBER)
            report('E04: Divide by Zero')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_pow(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.pow(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_logn(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if a > 0 and b > 0:
            stack_push(math.log(b, a), TYPE_NUMBER)
        else:
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_shift(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        if a < 0:
            stack_push(b << abs(a), TYPE_NUMBER)
        else:
            stack_push(b >> a, TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_and(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b & a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_or(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b | a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_bitwise_xor(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_NUMBER)
    elif precheck([TYPE_FLAG, TYPE_FLAG]):
        a = int(stack_pop())
        b = int(stack_pop())
        stack_push(b ^ a, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_random(opcode, offset, more):
    try:
        stack_push(random.SystemRandom().random(), TYPE_NUMBER)
    except:
        rand = (int.from_bytes(os.urandom(7), 'big') >> 3) / (1 << 53)
        stack_push(rand, TYPE_NUMBER)
def bytecode_sqrt(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        stack_push(math.sqrt(stack_pop()), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b < a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gt(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b > a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_lteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b <= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_gteq(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        if b >= a:
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_compare_eq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b == a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_compare_neq(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]) or \
       precheck([TYPE_REMARK, TYPE_REMARK]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
    elif precheck([TYPE_ANY, TYPE_ANY]):
        a = stack_pop()
        b = stack_pop()
    if b != a:
        stack_push(-1, TYPE_FLAG)
    else:
        stack_push(0, TYPE_FLAG)
def bytecode_flow_if(opcode, offset, more):
    if precheck([TYPE_FLAG, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()  # false
        b = stack_pop()  # true
        c = stack_pop()  # flag
        if c == -1:
            interpret(b, more)
        else:
            interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_while(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = -1
        while a == -1:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = 0
    else:
        abort_run(opcode, offset)
def bytecode_flow_until(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        quote = stack_pop()
        a = 0
        while a == 0:
            interpret(quote, more)
            if precheck([TYPE_FLAG]):
                a = stack_pop()
            else:
                if abort_run == False:
                    abort_run(opcode, offset)
                a = -1
    else:
        abort_run(opcode, offset)
def bytecode_flow_times(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        quote = stack_pop()
        count = int(stack_pop())
        for i in range(0, count):
            interpret(quote, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_call(opcode, offset, more):
    if precheck([TYPE_POINTER]) or precheck([TYPE_FUNCALL]):
        a = stack_pop()
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_dip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_sip(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER]):
        quote = stack_pop()
        stack_dup()
        v, t = stack_pop(type = True)
        interpret(quote, more)
        stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_flow_bi(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_tri(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_POINTER, TYPE_POINTER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        c = stack_pop()
        stack_dup()
        y, x = stack_pop(type = True)
        stack_dup()
        q, m = stack_pop(type = True)
        interpret(c, more)
        stack_push(q, m)
        interpret(b, more)
        stack_push(y, x)
        interpret(a, more)
    else:
        abort_run(opcode, offset)
def bytecode_flow_abort(opcode, offset, more):
    global should_abort
    should_abort = True
def bytecode_mem_copy(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_ANY_PTR]):
        a = stack_pop()
        b = stack_pop()
        copy_slice(b, a)
    else:
        abort_run(opcode, offset)
def bytecode_mem_fetch(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            v, t = fetch(b, a)
            stack_push(v, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_store(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY_PTR, TYPE_NUMBER]):
        a = stack_pop()     # offset
        b = stack_pop()     # slice
        c, t = stack_pop(type = True)   # value
        if math.isnan(a) or math.isinf(a):
            abort_run(opcode, offset)
        else:
            store(c, b, a, t)
    else:
        abort_run(opcode, offset)
def bytecode_mem_request(opcode, offset, more):
    stack_push(request_slice(), TYPE_POINTER)
def bytecode_mem_release(opcode, offset, more):
    if precheck([TYPE_POINTER]):
        release_slice(stack_pop())
    else:
        abort_run(opcode, offset)
def bytecode_mem_collect(opcode, offset, more):
    collect_garbage()
def bytecode_mem_get_last(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a = stack_pop()
        stack_push(get_last_index(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_last(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER]):
        a = stack_pop()
        b = stack_pop()
        set_slice_last_index(a, b)
    else:
        abort_run(opcode, offset)
def bytecode_mem_set_type(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()  # offset
        b = stack_pop()  # slice
        c = stack_pop()  # type
        store_type(b, a, c)
    else:
        abort_run(opcode, offset)
def bytecode_mem_get_type(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        v, t = fetch(b, a)
        stack_push(int(t), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_stack_dup(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_dup()
    else:
        abort_run(opcode, offset)
def bytecode_stack_drop(opcode, offset, more):
    if precheck([TYPE_ANY]):
        stack_drop()
    else:
        abort_run(opcode, offset)
def bytecode_stack_swap(opcode, offset, more):
    if precheck([TYPE_ANY, TYPE_ANY]):
        stack_swap()
    else:
        abort_run(opcode, offset)
def bytecode_stack_depth(opcode, offset, more):
    stack_push(stack_depth(), TYPE_NUMBER)
def bytecode_quote_name(opcode, offset, more):
    if precheck([TYPE_ANY_PTR, TYPE_STRING]):
        name = slice_to_string(stack_pop())
        ptr = stack_pop()
        add_definition(name, ptr)
    else:
        abort_run(opcode, offset)
def bytecode_function_hide(opcode, offset, more):
    if precheck([TYPE_STRING]):
        name = slice_to_string(stack_pop())
        if lookup_pointer(name) != -1:
            remove_name(name)
    else:
        abort_run(opcode, offset)
def bytecode_string_seek(opcode, offset, more):
    if precheck([TYPE_STRING, TYPE_STRING]):
        a = slice_to_string(stack_pop())
        b = slice_to_string(stack_pop())
        stack_push(b.find(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_slice_subslice(opcode, offset, more):
    if precheck([TYPE_POINTER, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_STRING, TYPE_NUMBER, TYPE_NUMBER]) or \
       precheck([TYPE_REMARK, TYPE_NUMBER, TYPE_NUMBER]):
        a = int(stack_pop())  # end
        b = int(stack_pop())  # start
        s, t = stack_pop(type=True)  # pointer
        s = int(s)
        c = memory_values[s]
        d = c[b:a]
        dt = memory_types[s]
        dt = dt[b:a]
        e = request_slice()
        i = 0
        while i < len(d):
            store(d[i], e, i, dt[i])
            i = i + 1
        stack_push(e, t)
    else:
        abort_run(opcode, offset)
def bytecode_string_numeric(opcode, offset, more):
    if precheck([TYPE_STRING]):
        a = slice_to_string(stack_pop())
        if is_number(a):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    else:
        abort_run(opcode, offset)
def bytecode_slice_reverse(opcode, offset, more):
    if precheck([TYPE_POINTER]) or \
       precheck([TYPE_STRING]) or \
       precheck([TYPE_REMARK]):
        a, t = stack_pop(type = True)
        a = int(a)
        memory_values[a] = memory_values[a][::-1]
        memory_types[a] = memory_types[a][::-1]
        stack_push(a, t)
    else:
        abort_run(opcode, offset)
def bytecode_to_upper(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).upper()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.upper()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_to_lower(opcode, offset, more):
    if precheck([TYPE_STRING]):
        ptr = stack_pop()
        a = slice_to_string(ptr).lower()
        stack_push(string_to_slice(a), TYPE_STRING)
    elif precheck([TYPE_CHARACTER]):
        a = stack_pop()
        if a >= 32 and a <= 128:
            b = ''.join(chr(a))
            a = b.lower()
            stack_push(ord(a[0].encode('utf-8')), TYPE_CHARACTER)
        else:
            report('CHARACTER not in valid range (32 .. 128)')
            abort_run(opcode, offset)
    else:
        abort_run(opcode, offset)
def bytecode_report(opcode, offset, more):
    if precheck([TYPE_STRING]):
        report(slice_to_string(stack_pop()))
    else:
        abort_run(opcode, offset)
def bytecode_vm_names(opcode, offset, more):
    s = request_slice()
    i = 0
    for word in dictionary_names():
        value = string_to_slice(word)
        store(value, s, i, TYPE_STRING)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_slices(opcode, offset, more):
    s = request_slice()
    i = 0
    for ptr in dictionary_slices():
        store(ptr, s, i, TYPE_POINTER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_trig_sin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.sin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_cos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.cos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_tan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.tan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_asin(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.asin(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_acos(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.acos(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan(opcode, offset, more):
    if precheck([TYPE_NUMBER]):
        a = stack_pop()
        stack_push(math.atan(a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_trig_atan2(opcode, offset, more):
    if precheck([TYPE_NUMBER, TYPE_NUMBER]):
        a = stack_pop()
        b = stack_pop()
        stack_push(math.atan2(b, a), TYPE_NUMBER)
    else:
        abort_run(opcode, offset)
def bytecode_vm_mem_map(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_map:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_sizes(opcode, offset, more):
    s = request_slice()
    i = 0
    for a in memory_size:
        store(a, s, i, TYPE_NUMBER)
        i = i + 1
    stack_push(s, TYPE_POINTER)
def bytecode_vm_mem_alloc(opcode, offset, more):
    s = request_slice()
    i = 0
    n = 0
    while i < len(memory_map):
        if memory_map[i] == 1:
            store(i, s, n, TYPE_POINTER)
            n = n + 1
        i = i + 1
    stack_push(s, TYPE_POINTER)
bytecodes = {
    BC_NOP:            bytecode_nop,
    BC_SET_TYPE:       bytecode_set_type,
    BC_GET_TYPE:       bytecode_get_type,
    BC_ADD:            bytecode_add,
    BC_SUBTRACT:       bytecode_subtract,
    BC_MULTIPLY:       bytecode_multiply,
    BC_DIVIDE:         bytecode_divide,
    BC_REMAINDER:      bytecode_remainder,
    BC_POW:            bytecode_pow,
    BC_LOGN:           bytecode_logn,
    BC_BITWISE_SHIFT:  bytecode_bitwise_shift,
    BC_BITWISE_AND:    bytecode_bitwise_and,
    BC_BITWISE_OR:     bytecode_bitwise_or,
    BC_BITWISE_XOR:    bytecode_bitwise_xor,
    BC_RANDOM:         bytecode_random,
    BC_SQRT:           bytecode_sqrt,
    BC_COMPARE_LT:     bytecode_compare_lt,
    BC_COMPARE_GT:     bytecode_compare_gt,
    BC_COMPARE_LTEQ:   bytecode_compare_lteq,
    BC_COMPARE_GTEQ:   bytecode_compare_gteq,
    BC_COMPARE_EQ:     bytecode_compare_eq,
    BC_COMPARE_NEQ:    bytecode_compare_neq,
    BC_FLOW_IF:        bytecode_flow_if,
    BC_FLOW_WHILE:     bytecode_flow_while,
    BC_FLOW_UNTIL:     bytecode_flow_until,
    BC_FLOW_TIMES:     bytecode_flow_times,
    BC_FLOW_CALL:      bytecode_flow_call,
    BC_FLOW_DIP:       bytecode_flow_dip,
    BC_FLOW_SIP:       bytecode_flow_sip,
    BC_FLOW_BI:        bytecode_flow_bi,
    BC_FLOW_TRI:       bytecode_flow_tri,
    BC_FLOW_ABORT:     bytecode_flow_abort,
    BC_MEM_COPY:       bytecode_mem_copy,
    BC_MEM_FETCH:      bytecode_mem_fetch,
    BC_MEM_STORE:      bytecode_mem_store,
    BC_MEM_REQUEST:    bytecode_mem_request,
    BC_MEM_RELEASE:    bytecode_mem_release,
    BC_MEM_COLLECT:    bytecode_mem_collect,
    BC_MEM_GET_LAST:   bytecode_mem_get_last,
    BC_MEM_SET_LAST:   bytecode_mem_set_last,
    BC_MEM_SET_TYPE:   bytecode_mem_set_type,
    BC_MEM_GET_TYPE:   bytecode_mem_get_type,
    BC_STACK_DUP:      bytecode_stack_dup,
    BC_STACK_DROP:     bytecode_stack_drop,
    BC_STACK_SWAP:     bytecode_stack_swap,
    BC_STACK_DEPTH:    bytecode_stack_depth,
    BC_QUOTE_NAME:     bytecode_quote_name,
    BC_FUNCTION_HIDE:  bytecode_function_hide,
    BC_STRING_SEEK:    bytecode_string_seek,
    BC_SLICE_SUBSLICE: bytecode_slice_subslice,
    BC_STRING_NUMERIC: bytecode_string_numeric,
    BC_SLICE_REVERSE:  bytecode_slice_reverse,
    BC_TO_LOWER:       bytecode_to_lower,
    BC_TO_UPPER:       bytecode_to_upper,
    BC_REPORT:         bytecode_report,
    BC_VM_NAMES:       bytecode_vm_names,
    BC_VM_SLICES:      bytecode_vm_slices,
    BC_TRIG_SIN:       bytecode_trig_sin,
    BC_TRIG_COS:       bytecode_trig_cos,
    BC_TRIG_TAN:       bytecode_trig_tan,
    BC_TRIG_ASIN:      bytecode_trig_asin,
    BC_TRIG_ACOS:      bytecode_trig_acos,
    BC_TRIG_ATAN:      bytecode_trig_atan,
    BC_TRIG_ATAN2:     bytecode_trig_atan2,
    BC_VM_MEM_MAP:     bytecode_vm_mem_map,
    BC_VM_MEM_SIZES:   bytecode_vm_mem_sizes,
    BC_VM_MEM_ALLOC:   bytecode_vm_mem_alloc,
}
errors = []


def clear_errors():
    """remove all errors from the error log"""
    global errors
    errors = []


def report(text):
    """report an error"""
    global errors
    errors.append(text)
current_slice = 0           # This is set by interpret() to the slice being run
                            # It's used for error reports, and as a guard to
                            # prevent garbage collection of a slice being run.
def interpret(slice, more=None):
    """Interpret the byte codes contained in a slice."""
    global current_slice
    global should_abort
    offset = 0
    size = get_last_index(int(slice))
    if current_slice == 0:
        current_slice = slice
    while offset <= size and should_abort is not True:
        opcode, optype = fetch(slice, offset)
        if optype != TYPE_BYTECODE:
            stack_push(opcode, optype)
            if optype == TYPE_REMARK:
                stack_pop()
            if optype == TYPE_FUNCALL:
                interpret(stack_pop(), more)
        else:
            if math.isnan(opcode):
                opcode == BC_NOP
            else:
                opcode = int(opcode)
            if opcode in bytecodes:
                bytecodes[opcode](opcode, offset, more)
            if more is not None:
                offset = more(slice, offset, opcode)
        offset += 1
    if should_abort:
        if pointer_to_name(slice) == '':
            report('BT: &{0}\t#{1}'.format(slice, offset - 1))
        else:
            report('BT: &{0}\t#{1}\t{2}'.format(slice, offset - 1, pointer_to_name(slice)))
    current_slice = 0
stack = []
def format_item(prefix, value):
    return  prefix + str(value)


def parsed_item(i):
    r = ""
    tos = stack_value_for(i)
    type = stack_type_for(i)
    if type == TYPE_NUMBER:
        r = format_item('#', tos)
    elif type == TYPE_BYTECODE:
        r = format_item('`', tos)
    elif type == TYPE_CHARACTER:
        r = format_item('$', chr(tos))
    elif type == TYPE_STRING:
        r = format_item('\'', slice_to_string(tos) + '\'')
    elif type == TYPE_POINTER:
        r = format_item('&', tos)
    elif type == TYPE_FUNCALL:
        r = format_item('|', tos)
    elif type == TYPE_REMARK:
        r = format_item('"', slice_to_string(tos) + '"')
    elif type == TYPE_FLAG:
        if tos == -1:
            r = "true"
        elif tos == 0:
            r = "false"
        else:
            r = "malformed flag"
    else:
        r = "unmatched type on the stack"
    return r


def parsed_stack():
    r = []
    for i in range(0, stack_depth()):
        r.append(parsed_item(i))
    return r
def stack_values():
    r = []
    for w in stack:
        r.append(w[0])
    return r


def stack_types():
    r = []
    for w in stack:
        r.append(w[1])
    return r
def stack_depth():
    return len(stack)


def stack_type_for(d):
    return stack[d][1]


def stack_value_for(d):
    return stack[d][0]
def stack_clear():
    """remove all values from the stack"""
    global stack
    stack = []


def stack_push(value, type):
    """push a value to the stack"""
    global stack
    stack.append((value, type))


def stack_drop():
    """remove a value from the stack"""
    global stack
    stack.pop()


def stack_pop(type = False, fifo = False):
    """remove and return a value from the stack"""
    global stack
    if fifo:
        if type:
            return stack.pop(0)
        else:
            return stack.pop(0)[0]
    else:
        if type:
            return stack.pop()
        else:
            return stack.pop()[0]


def tos():
    """return a pointer to the top element in the stack"""
    return stack_depth() - 1


def stack_type():
    """return the type identifier for the top item on the stack"""
    return stack_type_for(tos())


def stack_swap():
    """switch the positions of the top items on the stack"""
    av, at = stack_pop(type = True)
    bv, bt = stack_pop(type = True)
    stack_push(av, at)
    stack_push(bv, bt)


def stack_dup():
    """duplicate the top item on the stack"""
    """if the value is a string, makes a copy of it"""
    av, at = stack_pop(type = True)
    stack_push(av, at)
    if at == TYPE_STRING:
        s = request_slice()
        copy_slice(av, s)
        stack_push(s, at)
    else:
        stack_push(av, at)
def convert_to_bytecode(original):
    global stack
    if original == TYPE_NUMBER:
        a = stack_pop()
        stack_push(a, TYPE_BYTECODE)


def convert_to_number(original):
    global stack
    if original == TYPE_STRING:
        a = stack_pop()
        if is_number(slice_to_string(a)):
            stack_push(float(slice_to_string(a)), TYPE_NUMBER)
        else:
            stack_push(float('nan'), TYPE_NUMBER)
    else:
        a = stack_pop()
        stack_push(a, TYPE_NUMBER)


def convert_to_string(original):
    global stack
    if original == TYPE_NUMBER:
        stack_push(string_to_slice(str(stack_pop())), TYPE_STRING)
    elif original == TYPE_CHARACTER:
        v = stack_pop()
        if (v >= 32 and v <= 128) or v == 10 or v == 13:
            stack_push(string_to_slice(str(chr(v))), TYPE_STRING)
        else:
            stack_push(string_to_slice(str(chr(0))), TYPE_STRING)
    elif original == TYPE_FLAG:
        s = stack_pop()
        if s == -1:
            stack_push(string_to_slice('true'), TYPE_STRING)
        elif s == 0:
            stack_push(string_to_slice('false'), TYPE_STRING)
        else:
            stack_push(string_to_slice('malformed flag'), TYPE_STRING)
    elif original == TYPE_POINTER or original == TYPE_REMARK:
        a = stack_pop()
        stack_push(a, TYPE_STRING)
    else:
        return 0


def convert_to_character(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        stack_push(ord(s[0].encode('utf-8')), TYPE_CHARACTER)
    else:
        s = stack_pop()
        stack_push(int(s), TYPE_CHARACTER)


def convert_to_pointer(original):
    global stack
    a = stack_pop()
    stack_push(a, TYPE_POINTER)


def convert_to_flag(original):
    global stack
    if original == TYPE_STRING:
        s = slice_to_string(stack_pop())
        if s == 'true':
            stack_push(-1, TYPE_FLAG)
        elif s == 'false':
            stack_push(0, TYPE_FLAG)
        else:
            stack_push(1, TYPE_FLAG)
    else:
        s = stack_pop()
        stack_push(s, TYPE_FLAG)


def convert_to_funcall(original):
    global stack
    if original == TYPE_NUMBER or original == TYPE_POINTER:
        a = stack_pop()
        stack_push(a, TYPE_FUNCALL)


def stack_change_type(desired):
    """convert the type of an item on the stack to a different type"""
    global stack
    original = stack_type()
    if desired == TYPE_BYTECODE:
        convert_to_bytecode(original)
    elif desired == TYPE_NUMBER:
        convert_to_number(original)
    elif desired == TYPE_STRING:
        convert_to_string(original)
    elif desired == TYPE_CHARACTER:
        convert_to_character(original)
    elif desired == TYPE_POINTER:
        convert_to_pointer(original)
    elif desired == TYPE_FLAG:
        convert_to_flag(original)
    elif desired == TYPE_FUNCALL:
        convert_to_funcall(original)
    else:
        a = stack_pop()
        stack_push(a, desired)
dictionary_warnings = False     # Used to trigger a warning if a name is redefined
dictionary_hidden_slices = []   # Holds a list of slices that previously had names
dictionary = []
def dictionary_names():
    r = []
    for w in dictionary:
        r.append(w[0])
    return r


def dictionary_slices():
    r = []
    for w in dictionary:
        r.append(w[1])
    return r
def in_dictionary(s):
    for w in dictionary_names():
        if w == s:
            return True
    return False
def dict_entry(name):
    for i in dictionary:
        if i[0] == name:
            return i[1]
    return -1
def dict_index(name):
    n = 0
    for i in dictionary:
        if i[0] == name:
            return n
        n = n + 1
    return -1
def lookup_pointer(name):
    if in_dictionary(name) is False:
        return -1
    else:
        return dict_entry(name)
def add_definition(name, slice):
    global dictionary
    if in_dictionary(name) is False:
        dictionary.append((name, slice))
    else:
        if dictionary_warnings:
            report('W10: {0} redefined'.format(name))
        target = lookup_pointer(name)
        copy_slice(slice, target)
def remove_name(name):
    global dictionary, dictionary_hidden_slices
    if in_dictionary(name) is not False:
        i = dict_index(name)
        if not dictionary[i][1] in dictionary_hidden_slices:
            dictionary_hidden_slices.append(dictionary[i][1])
        del dictionary[i]
def pointer_to_name(ptr):
    """given a parable pointer, return the corresponding name, or"""
    """an empty string"""
    for i in dictionary:
        if i[1] == ptr:
            return i[0]
    return ''
memory_values = []    # Contains the slices for storing data
memory_types = []     # Contains the slices for storing types
memory_map = []       # A simple structure for indicating which slices are in use
memory_size = []      # A simple structure for indicating the number of items
                      # in each slice
def request_slice():
    """request a new memory slice"""
    global memory_values, memory_types, memory_map, memory_size
    i = 0
    while i < len(memory_map):
        if memory_map[i] == 0:
            memory_map[i] = 1
            memory_values[i] = [0]
            memory_types[i] = [0]
            memory_size[i] = 0
            return i
        else:
            i += 1
    if stack_depth() == 0:
        collect_garbage()
    x = 0
    while x < PREALLOCATE:
        memory_map.append(0)
        memory_values.append([0])
        memory_types.append([0])
        memory_size.append(0)
        x = x + 1
    memory_map[i] = 1
    memory_values[i] = [0]
    memory_types[i] = [0]
    memory_size[i] = 0
    return i
def release_slice(slice):
    """release a slice. the slice should not be used after this is done"""
    global memory_map, memory_size, memory_values, memory_types
    slice = int(slice)
    memory_map[slice] = 0
    memory_size[slice] = 0
    memory_values[slice] = [0]
    memory_types[slice] = [0]
def copy_slice(source, dest):
    """copy the contents of one slice to another"""
    global memory_size
    i = 0
    l = memory_size[int(source)]
    while i <= l:
        v, t = fetch(int(source), i)
        store(v, int(dest), i, t)
        i += 1
    memory_size[int(dest)] = memory_size[int(source)]


def prepare_slices():
    """prepare the initial set of slices for use"""
    global memory_values, memory_types, memory_map, memory_size, INITIAL_SLICES
    memory_map = [0 for x in range(INITIAL_SLICES)]
    memory_values = [0 for x in range(INITIAL_SLICES)]
    memory_types = [0 for x in range(INITIAL_SLICES)]
    memory_size = [0 for x in range(INITIAL_SLICES)]


def fetch(slice, offset):
    """return a stored value and type"""
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    return memory_values[int(slice)][int(offset)], memory_types[int(slice)][int(offset)]


def store_type(slice, offset, type):
    global memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_types[int(slice)][int(offset)] = type


def store(value, slice, offset, type=100):
    """store a value into a slice"""
    global memory_values, memory_types
    if get_last_index(slice) < abs(offset):
        set_slice_last_index(slice, abs(offset))
    memory_values[int(slice)][int(offset)] = value
    memory_types[int(slice)][int(offset)] = type


def get_last_index(slice):
    """get the length of a slice"""
    return memory_size[int(slice)]


def set_slice_last_index(slice, size):
    """set the length of a slice"""
    global memory_values, memory_types, memory_size
    old_size = memory_size[int(slice)]
    grow_by = size - old_size
    if grow_by > 0:
        memory_values[int(slice)].extend(list(range(int(grow_by))))
        memory_types[int(slice)].extend(list(range(int(grow_by))))
    if grow_by < 0:
        while grow_by < 0:
            grow_by = grow_by + 1
            del memory_values[int(slice)][-1]
            del memory_types[int(slice)][-1]
    memory_size[int(slice)] = size


def string_to_slice(string):
    """convert a string into a slice"""
    s = request_slice()
    if string != '':
        i = 0
        for char in list(string):
            store(ord(char.encode('utf-8')), s, i, TYPE_CHARACTER)
            i += 1
    else:
        set_slice_last_index(s, -1)
    return s


def slice_to_string(slice):
    """convert a slice into a string"""
    s = []
    i = 0
    size = get_last_index(int(slice))
    while i <= size:
        try: s.append(chr(int(fetch(slice, i)[0])))
        except: pass
        i += 1
    return ''.join(s)
def is_pointer(type):
    flag = False
    if type == TYPE_POINTER or \
       type == TYPE_STRING or \
       type == TYPE_REMARK or \
       type == TYPE_FUNCALL:
        flag = True
    else:
        flag = False
    return flag
def scan_slice(s):
    ptrs = []
    i = get_last_index(s)
    while i >= 0:
        try:
            v, t = fetch(s, i)
            v = int(v)
        except:
            t = 0
            v = 0
        if is_pointer(t):
            if not v in ptrs:
                ptrs.append(v)
        i = i - 1
    return ptrs
def find_references(s):
    ptrs = scan_slice(s)
    l = len(ptrs)
    ln = 0
    while l != ln:
        l = len(ptrs)
        for x in ptrs:
            new = scan_slice(x)
            for n in new:
                if not n in ptrs:
                    ptrs.append(n)
        ln = len(ptrs)
    return ptrs
def seek_all_references():
    """return a list of all references in all named slices and stack items"""
    global dictionary, stack, types, current_slice
    sources = []

    # Named items
    for s in dictionary_slices():
        if not s in sources:
            sources.append(s)

    # Previously named but now hidden items
    for s in dictionary_hidden_slices:
        if not s in sources:
            sources.append(s)

    # The current slice
    if not current_slice in sources:
        sources.append(current_slice)

    # Strings, comments, pointers, function calls on the stack
    i = tos()
    while i >= 0:
        if is_pointer(stack_type_for(i)):
            sources.append(stack_value_for(i))
        i = i - 1

    refs = sources
    for s in sources:
        for x in find_references(s):
            if not x in refs:
                refs.append(x)

    return refs
def collect_garbage():
    """scan memory, and collect unused slices"""
    i = 0
    refs = seek_all_references()
    while i < INITIAL_SLICES:
        if not i in refs and memory_map[i] == 1:
            release_slice(i)
        i = i + 1
def compile_string(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_STRING)
    offset += 1
    return offset


def compile_comment(string, slice, offset):
    store(string_to_slice(string), slice, offset, TYPE_REMARK)
    offset += 1
    return offset


def parse_string(tokens, i, count, delimiter):
    s = ""
    a = tokens[i].endswith(delimiter)
    b = tokens[i] != delimiter
    c = tokens[i].endswith("\\" + delimiter)
    if a and b and not c:
        s = tokens[i]
    else:
        j = i + 1
        s = tokens[i]
        while j < count:
            s += " "
            s += tokens[j]
            a = tokens[j].endswith(delimiter)
            b = tokens[j].endswith("\\" + delimiter)
            if a and not b:
                i = j
                j = count
            j += 1
    final = s.replace("\\n", "\n").replace("\\t", "\t")
    return i, final.replace("\\", "")
def compile_character(character, slice, offset):
    store(character, slice, offset, TYPE_CHARACTER)
    offset += 1
    return offset


def compile_number(number, slice, offset):
    if is_number(number):
        store(float(number), slice, offset, TYPE_NUMBER)
    else:
        store(float('nan'), slice, offset, TYPE_NUMBER)
        report("E03: Compile Error: Unable to convert {0} to a number".format(number))
    offset += 1
    return offset


def compile_bytecode(bytecode, slice, offset):
    store(float(bytecode), slice, offset, TYPE_BYTECODE)
    offset += 1
    return offset
def compile_pointer(name, slice, offset):
    if is_number(name):
        store(float(name), slice, offset, TYPE_POINTER)
    else:
        if lookup_pointer(name) != -1:
            store(lookup_pointer(name), slice, offset, TYPE_POINTER)
        else:
            store(0, slice, offset, TYPE_POINTER)
            report('E03: Compile Error: Unable to map {0} to a pointer'.format(name))
    offset += 1
    return offset
def compile_function_call(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if name != "":
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset


def compile_function_call_prefixed(name, slice, offset):
    if lookup_pointer(name) != -1:
        store(lookup_pointer(name), slice, offset, TYPE_FUNCALL)
        offset += 1
    else:
        if is_number(name):
            store(int(name), slice, offset, TYPE_FUNCALL)
            offset += 1
        else:
           report('E03: Compile Error: Unable to map `{0}` to a pointer'.format(name))
    return offset
def compile(str, slice=None):
    global should_abort
    should_abort = False
    if slice == None:  slice = request_slice()
    prefixes = { '`', '#', '$', '&', '\'', '"', '@', '!', '|' }
    nest = []
    tokens = tokenize(str)
    offset = 0
    if tokens == []:
        store(BC_NOP, slice, offset, TYPE_BYTECODE)
        return slice
    for token in tokens:
        prefix = token[:1]
        if prefix in prefixes:
            current = token[1:]
        else:
            current = token
        if prefix == '"':
            offset = compile_comment(current[:-1], slice, offset)
        elif prefix == "'":
            offset = compile_string(current[:-1], slice, offset)
        elif prefix == "$":
            v = ord(current[0].encode('utf-8'))
            offset = compile_character(v, slice, offset)
        elif prefix == "&":
            offset = compile_pointer(current, slice, offset)
        elif prefix == "#":
            offset = compile_number(current, slice, offset)
        elif prefix == "`":
            offset = compile_bytecode(current, slice, offset)
        elif prefix == "@":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_FETCH, slice, offset)
        elif prefix == "!":
            offset = compile_pointer(current, slice, offset)
            offset = compile_number(1, slice, offset)
            offset = compile_bytecode(BC_MEM_STORE, slice, offset)
        elif prefix == "|":
            offset = compile_function_call_prefixed(current, slice, offset)
        elif current == "[":
            nest.append((slice, offset))
            slice = request_slice()
            offset = 0
        elif current == "]":
            if len(nest) == 0:
                report('E03: Compile Error - quotations not balanced')
                return slice
            else:
                old = slice
                if offset == 0:
                    store(BC_NOP, slice, offset, TYPE_BYTECODE)
                slice, offset = nest.pop()
                store(old, slice, offset, TYPE_POINTER)
                offset += 1
        else:
            if is_number(current):
                offset = compile_number(current, slice, offset)
            else:
                offset = compile_function_call(current, slice, offset)
        if offset == 0:
            store(BC_NOP, slice, offset, TYPE_BYTECODE)
    if len(nest) != 0:
        report('E03: Compile Error - quotations not balanced')
    return slice
def parse_bootstrap(f):
    """compile the bootstrap package it into memory"""
    for line in condense_lines(f):
        if len(line) > 0: interpret(compile(line))
def prepare_dictionary():
    """setup the initial dictionary"""
    add_definition(':', compile('"ps-" `{0} "Attach a name to a pointer"'.format(BC_QUOTE_NAME)))
stdlib="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0l0Fy73b3NrYfDbQhMRAhCcTEvhv3vYj3ve53p3ov3wKpEEV38CP3Pq+v6z7UL6Po5wVDN3yFuyZutjeIT4BD5Ebqe56vX73uiK+UGKDFBhCETE/b21YWrzZwEbgvVV2u/VVQjTb1Avzw+aiZifpidREzEijdLXmogEECjrpAl9Xvp+Pp+75fe2one7p7efnCNDjRdt9iPnzYKLQAi7uLu5u7F1qG2hshVtvU20PvltNzElV562y/fbAJIR09M93d8hOPtc93dz77wlE473MzL9MTh8B1ofAAXd3eru7dPpiXLaLXvrRTm2vD6HtzEjkXZJOaG0u6quUWeaTSS+2choAl36Tnjvcd1Xk5S9F2W8NpY0Le912223mNs771mtfoQmYUfiRGEWlCRJFZlEAmAgUGvvvb77zYa1vtEdx30REffT82+ShCgEkJxSFh3Nucd/eA7AOwbyg7BuKfST6Ktly+ZzQunleOButAbOI0B8gs/E0s3nyaWZmATYtYCPBAAtoP2ZmZmZmB5Xq77XuyVJYLq6fbE3KUkPE1sK4gPukNFUQ0AF4klPSbkmWbDwHwSSTsk+l3ve/ccc5JmSTe6qq96WAAAxMyZkk3uqqr5YGD4MXm7zd3e993ve77sAAC83ebu73vu973fdgAAfXm7zd3e99+x9ve93XQAAGJP0mZJN7qqqcgAAGMXm7zd3fec3ve770AADF5u83d3vfd73u+7AwABebvN3d73jHr5znJewAAJmTN3d73jHfsfb3vd92AABtf46GBXx8FGgCzQWjRaABbQBRsB5Ve97oH0MhI++FOxXuNOXchw0ussKABSdkAAl34Im5Laf079IdDYeaYHxJPe97wr72Zkk3vGPb3vfuwAACZkzd3e94xVVV8sAHM5Bi2b1m7u97xipve+4l5AAAmZMy7ve8Ym973OwASSSSQnvV3ujveW+ehSvJzmrOe9ckkkABqfpMySb3jHd73udgAAAu8973u94xVVXedAAAw73Pe97veMc3ve+92AABM3ebq7vnMY3VVfegCMgYj7KT9JJzFsdYz3GM5fYxjnOfuJeQAAMY5h9i37vv32PsfPar3v379+BsBRoAsBmZmRkZmZgW0AUbAebmJqs9X2++ysbz7UN399d367YZ7MzOZgETJ4zMzMXdPe973veu7skgBy7u+Xd2bAO9Wd73uWa1oBgA39P0mdXd73jFVVXywAAMbxi/13nV3e94xWKqr5YAAH28Yxf67zq7ve8Y7vG97vuwAALzd5u7uc5i/sfcc5yXQAAHMT9f7N3d7lfY+qqnIBgALwn6azd3e9a1q92AABi89vN3d77VVV82AABee3m7u/2+1VXygAALzy83d33g8hfPPNdn6qqqqqqO9H7oEdqDJJJVzUPulhncTSA2AFppBYaACFgaAgsC2gCjYDzLte97fQlneq/vrRSmp9ZtXc+l7aaU1AKACpJAEYks0mlTaWpmZmZh73ve9773e9u93d3j9znOa93t3P36Sb36qr3YAABM3eZd3v9+1q92AABi812/367ve9a1fLAAAxee9zd3e9/a1VXywADAYvN3nl3e+/YxjWs/aW73IAAHb/XWM6u73KqqnIAA5ljO0taRuGwDvOc4daND1vS1raSbNw2Ad3VVU5GCfM5yYMZzP0mZJN7xiqqpy/kYMvssmJmTMknd8r99j7ed7ldAAIiIg277r+ISCEAoSAkjfo7L9839v7HR8B4bAUaD4L41HhcxPWwgCBbQBVdrVVuPbit7mJeFzQ00lf3wb3olnPatP1tO5A+aZoFsDO53NZzM3HCwgFW2AHoaZmc59j7ueu9rva7MySb9VVXuQAAC5+n7N3d71rWr3YAAGLz283d3vdVVX+0FBvLGCMiqRssqjeb3m97374e/b3vcvmGGAAGN4v9d5u77vefsfVVXygAAO572/13e5uqqcgAAEzcv9d3ve6qr5YAAGLzd3+u73vGN1VXy8AAAYvN3f67ut/sbrNXywAAMXnt4v9d33HKxv99j7e93ujCJmqN2Z3zyDvsQsTXqryQB8UGBQDyQRTFCBHuwhCIADmKGCjyBX1XmHIR5KoPIBDkAB7AvxDQkTISqhCEAjyUBOQB1M0w1yBUDFDnnSqA8g7kCgQCUOYAvOsBR5mKzERGomI/fr/fv2/379+GqPg88cQACABbQBVV6oqqFLj9r7cR+1rUo5zQpuLqkM52HOLNNpLPZxtLiTyZxtLPqXzTSYfLmczMzMAxtI02mce20tJpkaYB1GZhcNhmJtPMzMvPLNZzAO38YoD99gAn0/ffb31ve/ee+eec/bqqqoBc/T9f67vda1q92AABi89u/13e97qqvlgAAYvN3f67ve/t1VXywAAMLXd/ru9ysc5f2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e6uucxznNfffbSSaAAAiX11rnO5ncrMwDgOh8B4bAUaALQSAIAKqsu9XeEk9cSn30DYBdwDbaUknJNwBAGNpYBtpN8aS02lpAIAzE3k3LacWpKk3JJJJPe573vsyTMzOZWb73v3My81rWta0ACZkk1MVVVJOwAADEu7vcqqrkkvQAACXd3WJVVXKu+6AAAYu7u71WM1Vcx99qSTFGEFMcsbLI3POc5w+857771zmj642WVQHpJPa1rXvemPMGD3zLJ6ST2ta1uve9PN4ZfGQPZ973va3jNVXNSXoAAD7ubu71eKqq59j70l6AAAxFZ1RpsFGkERE/VNvav7m/Ntv5AX999993MzPgPNwfAtRoAtBIAgBbV3u9XW71G7jcxC7uLm8l99bI2te+BHO3cOM1qSSSFxN3d2LG0pNtpSYtAGS/Wru7sknpNyd73m+67r7MvMzL4serP3m97/Y1737wAAF5jEkm9a1qSdgAAGJm7u5K5jfOc72TegAAO5u7u9Na1zV33QAAC13d3rWta59j6SXoAACZkk1Pb9z3vsyZFve971pJLW9b1re96Ws2AcWVuqqszOQAwAYmZJNSpzH7nOd1JNAAAa7+l3e6qqrl3z8AABee9++13333+R3veu6qqqqqqRBTyBVQ+nuQXUqKedUTG883v77e9c3ve+t53KzMv2ZmfYGnhsWKNAFoXd3d3dwILv3rqu7XfufDblzvfr1fvrvsZd/fJJQ21izbaWcCwPs8XdX4TTSxrTT01pa1qab22lrTUmIAwu7V3d3kklxdt73++x9veZySST1e3ve9e9fgAAPZk1JU23VfpJ2wAAKn6T3vc3jfu4x+7znvV4AADmb73upVVV3ywAAMXnve9vWqqubknKAAAmZJJqZqq7qpLoAACZkkmmta5JL0AABM4l3c1KquyX+AAAtP0u73yqqqx99d56AAAYt3ve3r1VVe96/AAAFvvvgQPIVVN5iKpkIoUoMEoPQKQg5KDMgKnUAvUqC0qRAZ1iqnS0SIp3IgB4nOvOGv379n4WOA6HwHhsBRoAtC7u7u7uCpiTd37vte9A3MTVX2K2vd+3Ds+acgvruTgG2mABPS7u/Wru4pBphACC0SSSX5p3q6vs973jwAGt4m977ypJQAAFsySalKqv0k7YAAEzJJqVM73uTsAAAxMzve6uqquXffwAAHb/X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rVVUD9nWYBwKqrVZm7uqlVVmRXnnnjnAAAPvYPGgAAAfe86zLMzrrO+3tX1VZ99999mtcGhoP4f2vMy3uqq25mZntVFYDEUB8tv97bbbbC5n7Mz4opEUVgI+W899ttttuZmZ6Vdf2gGjT72vd7qqs+++++3n9oBoEVHzMvvuZmZnLznOe4RFFYKMbz+t/vvrbmZy85znuEYoiiiinmZffczMzMyzMzdo0aaAB97Xu95mZmfX1mZyAAA3r+1r2vdb3VVZ99999vAVVVVXP6gBCUgIEIT+zPc5zmZQAAAeYHafAAAAAAAqqqVVVAAG5gAo37u7u+aCfFW6zzzxzlmPgAAAAAALbbbkhJCkBkkkf37z9bbbbc5znOX6gAAe1ve6qrPvvvvt4AAB5mW91VVZmZm4AADyre6qq1qzPczOQAAHlfa3uqqz77777eAAAeZlvdVVWZmZuAAA8q3uqqz77777eAGgC1/a17Xu91VWfffffbwAADzMt7qqqzMzNwAAHlW91bbbczMz2qqqqqq8kkILPUILIEISSskgSTn7nPb9mW22222222gA6ABgAAAABVVUqqqAACqq1bu7rb5AszHxVU5znOcAAAAAAAALMzrrM6/Z1meEDyEkIfvL+tttttuZmZ7VVVVVDyre7MzMzPrMzcAABv7X9rX6vecqzMzPrM/QAAFqre6qqszM/QAAFVvdVVWZmfoAACq3uqrM++++/YAABV5b3VVmfffffsAAAzK3uqrM++++/YAABmVvdVWZ99999vAAAL+9vLe6qsz77777eAFVVV4SQA/mEkJJPf4PvP77LzmW20AAAB8zrMAIAAVVVAFbu7utVVQAAVVWmYMwNOuswAVXWU5znOcs6zHwAAPPv0OAAW22222230gZIAQPSQYQD+ICSEJB/r+t5ctuZznOc9xVVVVVXzLd7qqzPvvvvt4AAB5lb3VVmfffffbwAADzK3uqrM+++++3gAAHmVvdVWZ99999vAAALNf39r9e+73VVms+++++3gAAH39r3L3e6qr+1WZmZuAAA8q3uqrM+++++3gAAHmVvdVWZ99999vAAAPMre6qsz77777eACqqrySLCQD8rnngEJKsIRJAwkz35Q1Q51ihr1Q2ouZnKhtQzvaJt0juocUNlzc/pv/bP+zjLrmc1izOuNysD+xQ/vPah3UPGv7M/dPc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3O0fQj7mYjVKWH5HOJU/tc5+9/X1lVWZmZuAAA8q3uqqrMzM3AAAd173vec73vaqzMzNwAa0a0a0aNd173vec73vaqzMzPA9ooooooKM6QP573vv3e8ve977Os6223wPp0UiiKKk5/d7377vb22rMzM3DQ/tA0P7XlW91VVZmZm4aH9/DQ/v53Xve93zve9qrMzMuAYqRUen7ve/fd73tttzMzPaipBRinSB+73vv3e97bbczMz2qRFFYKI9upKklVzCpJVVKlQ73e+9e973ve973ve973u7u7u7u7u7u7u+1XoAAAKqqgAAAAAN3d3d0F1mY+Arzvz545xVVUAAAAAALMzOuszM7zPlmfM66z+1+/Xv6rKqszMzc00A0Dyre6qqszMzcAaAO6973vOd73tVZmZm4AADuve97zne97VWZmZuAAA7r+1r3ve853ve1VmZmbgAqvQgeeeEDWQH9+/ED8kB/t3ec3d2225mZnt0gakB/fvP0kP35VVVVf7d/29/7/f7/VVmZmbgAAO6973vOd73tbbmZme1VVV7PPPA1IH78q+H9u799u/7/VVmZmbgAAO6/ta973vOd73tVuZmZ7VVVVVVeSEJJ/IBIQ+wRfAAAJBOf3L7mXnKZmZmZnOc5TMzMq3d1lVVbtVAAAAVVVAAAAAAbu7u7oLOsfFTrK++eeOcVVVAOweAAAAF1mZmZnXWe/v3vfvvvvvaqzMzNwAAHlW91VVZmZm4AAC1ruv3ne853ve1VmZmd1rnQA81rzwDzXve95zve9qrMzM3Hda88AAPNa/te973nO972qszMzcAAB5Vvde6/taqq5mZmb/tR/teeAAHve93vve9qrMzM81rcAAB/tfu97zne3aqzMzNwAAHde973nO972qszMzcAAB3X9/a973vOd73tt71nbf1t+6qqqqqr6YSQDiAQkFJJJAJ+IHOc7z7OW225mZznOdyqq3d1XmVfq3d330PffffQAADAAAAAAAAAA7AN2888c4qqqAAAAAAHedZnGdZjrrMz+/tb377bvqqrMzM3AAAeVb3VVVmZmea1uAAA7r93vec727VWZmZmtcgAO688DzX793vOd73tVZmZm4AADuv7Wve+a13vOd73ve3e9r9VzoAAb8881r+973vOd73tVZmZmIHchFSe85wgqQVCRUhw5zhACVAJUAlTfve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IG21tt/XfUgqQVIISoBKgEqASoBKgHtVPviVN+97nPe95Vu7u7eZKgEqASoBKgEqASoCQVIKkFSHNt3u21ttttt73EFSCpBUgqQVIKkFSCpBUk5tu922222htubXncQVIKkFZIHvqk++JUAlQCVAJUAlTfve5z3vezbbbba/2IfVIMIPkSHkg+JB8IIpDzwgwikGKQ88IPNt87ttcQNtbbbu4h54QYRSCKQ88IIpDzwqa1KgEqAST9NzVzp3eZxcVVVVUAAAFbu7uuqAAVVVKqqgAAAAVVcbu7u4D3PfffffffffeZznOc4AAAAAAAKrzOsz79q8hbbbbbe999gc4kFSCpB8ID4QVlQ1KkNSoBKgEqASob972+e97yqyW3lt53EFSD4QHwgqQVIKkFSCpBUgqQ5tu922u2222273ENxG4m7qbupu6m7s/2c5qbiNwgqQVIfPfnvr333327bW227uIKkHwgPhBUgqQVIKkFSCpBUhzbd7ttcQNtbbbu4gqQVIKkFSCpBUgqQVIKkObbvdtrbbbbb3uIKz3yHOJBUgqQVIKlQCVAJUAlTfve5z3veVWRX5X7mSoqQVIKkFSCpBUgqQVIKkObbvdtrtttttu9xBUgqQVIASoBKgFSAV774k+mtSffEqb973Oe97122ttt3cQVIKkFSCpBUgqQVIKkFSHNt3u21uIG22229+/cQVIKkFSCpBUgqQVIKlQCVB+lSalSXd373LvyqqqquZmZ777776ABW7u7q+Z1mQCBVVU5p9/AAAAAAAPQDHoADnXWZznOc57nWZ7777777776AafQAAAAeZA30gekD0gY/d7/dvbbbbC2/rb++0gBKgEqASoHp9U1qa198SoBKgEqASoBKm/e9yc973lW7u7t5kqASoBKgpBUgqQVIKkFSCpDm273ba3bW227tIKkFSCpBUgqQVIKkFSCpB5tvndtrdtbbbu0PTyHOc4BziQVIKkFSCpBUgqQVIfPffe99999txA22223v37iCpBUgqQVIKkFSCpBUgqQ+e++977777bbQtvLbzuIKkFSCpBUgBKgEkD30k++JUAlTfve5z3veXkiv1tt73EFSCpBUgqQVIPgPhBUgqQVIc23e7bW7a223dpBUgqQVIKkFSCpBUgqQVIPNt87ttbtrbbd2kFSCoHvOcIKkFSCpBUgqQVIfPffe99999tuIG2223v37SCpB8B8IKkFSCpBdTd1N3Vbup+vWCMUOYm1DKhksVDcqh45/KGXKhkt/3Ov82juoZRlQySWVDrrkk5LFDKhz/bLz93L1QyCnJQxWZUOsPvq50M4zTP9l3nPne8x5ajz9zrc+gu6htQ+73c86o4A6qGqGVDZMqGKM33IeKGVDqoZEmKHKee/vriKXv2qqs85RyQZ9UNkrmSjEYoTqjiSvO6Tih4SB/SAMxIHxz71KfBhffMznOZbbbQfcAaAAACqqoAAAAAAAAAHzALaqoAAAAAAAAAAFVVQA6AAAAA+AEAACqqoAAAAAHQAAAAFVVQAAAAHH34dgAAALHwKqqgAAAAAP8APQAAOc5znOADcPoK7+VXlAAAAAAAVu7u6oAAAAcwfgFVVQAAAAAAAAAAFVVQ8wOwAAAAAAAAA3d3d3QAAVVVd4DwADN6zzzzzw0AADMAAAAAAAAH4DgAAANw+gAAKqqgAAqqqAAsz8+g0AAAN6PoAAAAAAAFVVQA+ALd3d3QAAVVVAABVVUAAAABgAAAAAA5znOc4AABbu7u6l93mZznWd51584z8gAAAA855554NgAAABnMxmPMfGZnzd5zm6ACfAAB1u7u7uh19+fPmAIAALMvPPPHOAAAAAG5u7u7oAAB1555554KquV9AAAAAAcH4AAGZ1gAVVVAAA7zAeD7mANPmYAQAAAAA/Z1mAcDrAAAAAAAAAAL8+g077755nPg88qgAAAAAAAAAAAAB+AFVQABzB+AACqqoAAAAAKq+1Q0AAAACqqoAAAAAAAAPgBAAAe/HlHEuz9O9JH6Eeado/Ud0cd1D1Hz5HKh92dfVDqUMS5LKj6SWS5LmpcqGo2WI4qHpx2j5H+do89R+Aufqh6jH99nSP4+PkfyOpWZnM+ddZnMzLs5zUAAAAAACqqoABVVUAAAAAAABmVbu7mqgA888888AAA+gNAAAA6zvOszvMd9/QoFC2/rb++6Q8SCkFJFIKQUgpBSf6eJ4H9u78c3d223MzMy91BRZPPA8h4kFIKQUgpBSCkFIft3fd3d23ve2229KQUgpBSCkFIKQUgpBSHne99ttzlzuZmZcIKQUgpBSCkFIKGoqePigoPngeJ5mnru+7u7nOkDO5mZm9pBSCkFIKQYkEEgpBBIMBIM/bu/3e97nOc3MzM7DRgiRGCMEYIwRxkh4xY3Dc3LZjdWsmZmTdaMYmankix88h4qRX9u793ve5znA3M/ZmfthrYybu5izMYM3NWZmDM3dTMY3ZuMxY3ZuZkzM3Zpg3FuTcTMQ3+d33d3dtC97e973vfcIKQUgpBSCkFIKQUgpDv573073ve3O3MzMy4QUgpBSCkFIKQUgpBSHne9973ve3M6QMzMzLwgpBSCkFIKQUgpBSCkH099973vO9tttttttoAAACqqoAAAD4AQAAAAACq3d3FUAHfnzzzzwAAAAAAAA/Zm51md51mfA/v63+tttzOc5znM6QUguiInnh4Kozc2sZMbs1gxlY3NWYzGbu5Cr4kFIft3fd3d222222/dIKQUgpBSCkFIKQUgpDzve+973vbb3vQ73v7ve/sIKQUgpBSCkFIKQUgpDzve+ne97223tttveEFIKQUgpBSCkFIKQUh53vfe973ttvSBbbb3hBSCw1RCeIA+HhFFJ5u5kzMybu5lYxZum5MzN3cTMzc2FWCn7d37d3dtttttv2zVU8SCkFIKQUgpBSCkFIft3fd3d222wtv62/ukFIKQUgpBSCkFIKQUhhA/d7+973ve229ttt6cIKQUgpBSCkFIKQUgpDA/d7+973ve229ttt7wgpBSCkFIKQUgsDWC+eeCh4kH9u7/b3vczMpAzbbe8IKQUgpBSCkFIKQUgpD5kDrr+ZZV/f3Pf7+AAALMfAAAKqrqgAAAAAAAAAAA5nWZZmX3MzMwttvdDd3d3d3ew5znOc53vbbbb3ve7bbw2222121ttttuhtttttpA98kkP37d3e97mZmGbcz3pBSCkFIKQUgpBSCkFId/d737ve5223MznL0gpBSCkFIKQUgpBSCkE8tv9bTvbbe222/iB3hBSCkFIKQXVEik88PCKsHx8IqkfHwirBPPJPFYK0ge7v77du7bbd73ve95yGosZjd2YxY3GsxbiZiZiZiZ9qFSCsh8999733332224gbbbfe/SCpBUgqQVIKkFSCpBUgqQ5tu922tttttve4gqQVIKkFSCpBUgqQVIKkObbvdtrbbbbb3uIKkFSCpBUgqQVIKkFSCpDm273ba227bbb737PfJ4eE5zhyHnnnnOJBUgqQVIKkFSCpBUh8999733332227bbbhA+9+kFSCpBUgqQVIKkFSCpBUh+IH9tzvd+2tttxA22337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WZVZlSq9zA9999993d3d3QAbnWYfRj5p9BAAAFt0gbBhEhApA9IHkgEnvu79u7vaszMzMvvgAAPa3vdVVmZmZnOAAAXte73VVZmNazMzmwAAPMy3uqqqqrnAAAPKt7qqrWqr9V3X9rWYAAVXeHu7+++3d225mZmZecVVVVVV/Vve6qrMxrWZmc2AAB5mW91VVVVc4AAB5VvdVVa1VfqvfvgAAPa3re6qrMzMzP9IHOKqqqqq6hn8QJfDwIIkD+kgCkgGne97t+3dtttttttttttoG9n4cAFVVQB5gd1VVKqqgAAqqqB9zN3ed8N3VQG7u7u6DrAAAAAAAB/Z9zrM+Pv739777777VmY1rMzObAAA8ym91VWZmZmc4AABc1/a1+r9zl9VWZmZmc4AABe17vdVVmZmZnOAAAeZlvdVVmY1rMzO6/ta+4AAB/v3e/7nP9/v9/qqqq5wAADyre6qq1qq/VffAAAc1/a17Wa5y+qrMzMzOcAAAva93uqqzMzMznAAAPMy3uqqqq2+hpA54qqqqqrvO+yE/SQDw8mZnz511mPc8999/rn9/AAAAAAABVVUAA6HzrABVVQAAAADd3nOfW5mdne973ve97znOc5zm6kBIG7u7u7u2gAAAAAH9mdZn9nWZ8ICQGQP37d3d3czOc5zm598qqqqqL9+r9zlWZn33331nOAAAb/v7Wvcy/c5e2ZmZmZlc4ABo15VvdWZma1rMzP2srnwAAPK+3uqqqv8d73v8QOcVVVVVV2+7v777d3bbmZmZnOAAAeZlvdVVmZmZnOAKqr3zzfPPDkge97vObzdtttttv3yqoHdf2teeB+/d73nO97VZmZmZzgAAHvuZc5VVZmZmZ3X9rX3wAAq7+kgGTzyXSB073u/fbu22222222gAAOgYNzMAFAAHzOswDCVVVAAAAAKqqswHvXvvvvvvvvvv911mV8zMzMzZASBu93d3d362/rbf1ttv1ttttttttttttNADZASBwgIQPJDCYjEYjCpiMRmUYjz8QPffN3d5u222222/fKqqqqq/v1XOVVVrVV+q++AAA5/f2tfubr376yqszMzM5wAAD33MucqqszMzMvvgAAP36uc5VVZmZmZ/tf2tffAAAfv1d5zve1VVVc4AAB77VzlVVa1VfqvvgAAOf39rX79WffWVVVVXOAAAffv1fucqqsz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AAB77lc5VVmZmZmc4fa/ta88APNf2teeBb3e85yqrMzMzM5w+1r+154Aef39rXngW93vOcqqzMzMzOcPv7+1rzwA+9dZn378+fPm/d63djQAAAAH4s6zHw4AAAAAFVVQAAKqqgABmCrd3dWqqbu7u6AAPlfKq2QAAAPPmdZn799DQZmZmZnSBzmSB54qqvkgeeKq++3v333e9qzMzMzL77P7+1rzzz+154AAb3c5zlVWZmZmZzgAAHvuVzlVWZmZmZffAAAfv1u5yqrMzMzM5wAADev37K++rMzMzMzM3sAAD33MznMqq1qrP2Zndf2tffAAAd3vud+853uZmZffffb2AABr336zlWZn319999vYAAHvv1nOVVVWZmb2AAaPdb35vMzMqqqgAAAAAAAAAAAAAAqqqAAMyrd3jd1aqpu7u7oKqqh9OD80AAAD93nWZuQPZA99t9ty22hbbfbbwhxRESCtNNb/fvJc5VVmZmZmc5poAAd/frvfvvu973veaqqrNf2tffAAAefv13v33e9qqqq5wAAD32rnKqrWqq3V98AAB77cucqqqqq5w7rXngAB+/d73nO97VVVVzgAB3WvPD9+73vOd72vvvvvvvvu6/ta++ADzWvPAO7353vOd72szMzMzOcDuteeAAfv3e95zve1mtZmZm8zPvgAAPt/e/3ma98++rllVVVVVUAAAA+gCqqAAeYHYAACqqoAB8zd3d3hVWqqbu7u6DrKqqgB11mAAAAHue999/vfffe9r77777777nAAAPfauczMzPvvrMzOcAAA5+/ZX31ZmZmZVXOAAAe+1c5mZmZ/azMrdXvdf2tZgAAHu99965zv93tVmZmZnOAABeefv1u5zMzM+++szM5wAA+8888De7d85d3d3d2qvOdAAAAkoCqDWg/fq5zlVVrWqq3qr74ADuv7WvPA/fu/d5zve1VVVc4AAB77VzlVWZmZmZzgAAGtf2v7bWv79l3kfyh/lQxioYIxUMXWZnzrrrMxnPOXv9z33+AAAAAAAAKqqgAAOgAAAAAAN3dzN3f2/Af3Pfffffffffaqquusz33330Kq9NPoAAAAP7rM66z+zcz++/iSAfffe7u3dtttttt0gc4qqqqoea/fu97993vaszMzMznAAAPfcrnKqqqqucAAA99q5yqq1/VVur74AAD/a1ze++9++73t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57lc5VVVVV5rXOAAAfv1mtTnKqrWtVVvVX3zQAA99uXOVVZmZmZl98AAB+/W7nKqszMzMy++AAA/frdzlVWZmZmZ5rXmtc4AABe7vbnKqszMzMznAAAPfcrnKqqqqucAAA99q5yqrMzMzM7r+1r74AAD9+u95zve1bbbbb98qqqqqr2SBAk2BIwKjvKqpnWalOSwQPMv7+I74/uce/xVVUCqqoFVVQAAAAAAHM6zK+1VAAAADMq3d3M1UAG7u7u6AAB+/Abq7zrMqu6gAHmdZnudZn7Oszv537777e+i1qqt1Na++AAA89uXOVVZmZmZnmtX3wAAG927nKqszMzMy++AAA/frdzlVWZmZn29gAAVr9e3OVVZmZmfb2A/jWhQUixz9lv31ttttttt6QPA+OKqAHn7ve853varWqq3qr74AAD325q5yqrMzMzM5wAAD33K5yqrMzMzM5wAAD33K5yqtttttv3yqqqqqvSSBxIAoQO+eEITSEhwJbebve85znOc5znObmZmZlu7u7u7u7uqoAqqqAOZ1mV9qqVVVAAAABgq3d3Vqqm7u7ugAAAAAAAHMzn9111mZzOsxmfc6zrX9rX333d9rvarWqq3U1r74AADzf68ucqqzMzMzPda5wAPteeAb3lznLKrMzMzM7r+1r74AADu9997zne9qzMzMzOcAAA99yucqqqqq5wAAD32rnKqrWqq3V98AAB77cucqqzMzMzL74AAD96/XtzlVWZmZmZzgAAHuvcrnKqszMzMznAAAPde5XOVVVVVc4AAB7j+/vfmfPnzPvfmc+fXmeJVbu6yqqt3dZVVW7usr7VAFVVQBVVaqqgAAAOsAYKt3d1aqpu7u7oD7mANABVmZmZbbbbbbeB0gapAZIBSB6QPwQg+7vPt3dttC22+23nFVVXQ88A5vffe853vaszMzMznO6154B5rXngHmteefv13vOd72rMzMzM5wDuteeAea154fv13vOd72rMzMzM5w7rXngHmteeAd3vvvec73tWZmZmZzh3WvPAAD9+u95zve1Wqqq7r+1r74AADet773v33e5mZrMzMzN7AAA99zM5zMqrVVVe61zgAAH79VzllVaqqrnAAAPfaucqqtVVVzgAAHutd61azN5zvM7mffffdzMzMrd3VVVbu6qgAFVVQBVVV4HYAAAVVVWVVUAAN3d3d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77VzlVVVVXOH+1/a154Aea/ta88D9+73vOd72qqqrnDuv7WvPADyVIGta1veZnOZmKqqq5Kk73WiVIGtAea/ta88D9+73vOd72qqqrnDuv7WvPAM1557r+1rzwN7737nO97VVVVzh3+/ta88AAP37ve853vaqqqucAAA99q5yqqqqrzX9rXOAAAea91rnPftfbr9VVVVVVVVVAAAAAAqqqDAAAOweBVVUBXWbu84szVve7qo3d3d3QAAcfjsNAB+A4DzM766zPczMzOu+/fe9zt2qqqrnAAAPfaucrve973ve97V3X9rX3wAAH793vec73tVVVXOAAAe+1c5VVVVVzgAAHvtXOVVVVVc4AAB77VzlVVVV7r+1quegAAe+1c5VVVVV3X9rX3wAAH793vec73tVVVXOAAAe+1c5VmZmZmZXOAAAe69q5yrMzMzMy375VVVVVXdkgHP372fuc/U6zP7+++v4AfcwCX0AH4DgnwAABVVOj6AAADmdZg/BVVUBfd3d74bvG8bupu7znCqP2YBwcH4AAHmdZgdg7zrM5/Z1md9+++89vfQqqrnAAAPfaucqqqqq3r+1ruv7WvvAAAP37ve853vaqqqucAAA99q5yqqqqrnAAAPfaucqqqqq5wAAD32rnKqqqqucAAA99q5yqqqqruv7WvvgAAP37ve853vaqqqucAAA99q5yqqqqrfH8Ab88+883uuc5ZVVVVfd6AAAAAAAAATvMqqkll3mXmYAAAAAAMAAO8wHiqqoAAAAAqqqAdKqqhVu7upu7znCqAAAAAAAWVJ9JqqkyqqSMqT9+3m8zMxVVVXvegAAAAAAAAE3td84qqqqrkqS7sAAADWgNa1oD9+zOc5mYqqqr3vclSfa+++AAAAAAAD9+zOc5mYqqqr3vQAAAAAAAAN7XnOKqqqq970AAAAAAAADe15VSc4qqqqr3vQAAAAAAAACb2u+cVVVVVyVJd2AAAAAAAAB+/ZnOczMVVVV73oAAAAAAAAHP35e962qqqq970AAAAAAAADn78ve9bVVVbvnOAAAAAZJ998AABzP0lSp6VU++u/ezM8qoAAAGAAAAAKqqhVVUAAAqqqAqq3VmVV/e+++++++++7u7u7oAAH4DgAAAH35kBIGkkA8IH4PObfNttbbbbf37ve4n33wAAAH0n33wAAHOcXvet4qqrd5Kk7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fW/t83eaAAAADqqqo8zz5nzPA5zgAACZlzL9u7+1WdZk+gAAAA6wAAAAO+usxz7znOcHoOZ1meafe/fAAAAAAAAAO866zLOszc6zH1+eAAAAAB4HYAKqqgAAAAA7B4DrrMAAAAAFVVQAAAB++fss3v7+4/OPN2qqoAAAAAAAAAAAACqqoAAAAAAAAD7nWYA0AAAAAAAAAAAAAAA+Z1mAEAAAAAAABZlnWZddZlnWZ5Z0ZL5H40V3+I78KHSl+RhNqUsSNI8R+RyofkZ+yj77pH5T8pxHxlHqOI6qGMz1GoxGKH5GqPJfZUP1Q9R18jlQ+C7Ryfv3Kh0jvVdoySW+o8qGo/IyodUdjn47R+R118/USwRyoYopik84lDchHIowUZudZn3rOuszP3XWZK52qgAAAAAAeD9VVQAAArd3d1QAAAAKqzOV9gAHWAN3d3d0AADz8HhoAAAGdZnzOsz788qqqqqqvvgAD/eeH793u9973tVVVX3wBo/j32t7rMzMzMyq++AAA3+/VzfKqqzMqu6/tazAAAP37vd773vaqqqvtff38Gn9oe+1vdVVVVV98AAB77W91mZmZmZVffAAAb/fq5ysqqqqvvgAAO/v3e853ve1VVVd1/a1mAAAfv3e733tmZmZmdq++AAA37/xmfszne97VVVVVAAAAPgqtqgAAAKqqgAAAAVvOc43VmA/uvfQHu7u7ugAAfgOAAAAfv7MzM/fvffed73tVZmVX3wAAHvtb3WZmZmZlV7rX3wAAHn79XOVlVVVV98AAB77W91mZmZmZVf7X9rWYAABze+95vne9qrMyq++AAA3+/VzlWZmZmZVffAAAe+1vdZmZmZmVX3x3WvPAAD9+73e+97rtVVVX3wd1rzwDzWvPA/fu93vve9qqqq91rX33da88A81rzwB5rXnu9979zve5mZmZlV98AABa/ta3M6zd3e/FPAD5gBAAAAB9zAGgAAXT4K86yr9UAAAGAOsrec5xulVWqqbu7u6AAAAAAAA89z9+999931VVXo34AAD32t7q/tVe/2pVftalX3wAd1rzwDzWv37veZ93vaqzMqvvgO6154B5/a88Ob33vOd73MzMzMqvvjoeeKq+B54qr4H9/d7993tzMzMzO23nFDuteeAea154c1vfe853vczMzMyq++AAA99re6zMzMzMqvvgDQB77W91mZmZmZVffAAAe+1vdZmZmZmVX3wAAHvtb3VVVVVffAAAbfb559v399VVVAHmB2AAAAAAAAAVVVAAAAA7F3vOc43SqrVVe57VVe+gDvMB4AAAAAe9CH8QPvD33ve9ud7bbbbbb6HOKqjB/aa/fq/b5VVVVV9r4AAPfa3uqqqqq++AAA99re6qqqqr74AAD32t7qqqqqvvgAAPfa3uqqqqq91r74AAD9+re6yqqqq++AAA99re6qqqqr74AAD32t7qqqqqvvgAAPfa3uqqqqq++AAA/d/P7X9+1r595vPfePQABuddYfQAAAFVVQAAAAAAFVVQAczrMX3d3d1SqqoDd3d3dAAB4HYAW22222223+IH8QP4gdxA73bdtutqqqvvgAAPfa3uqqqqq++AAA99re6qqqqr74AAD32t7qqqqqvvgAAPfa3uqqqqq7r+1rMAAA81+/d7zne97VVVV98AAB77W91VVVVX3wAAHvtb3VVVVVffAAAe+1vdVVVVbecVVVVVV/fre/bzd93d3d3ve227pAtVVVVVV8hP0kATu8PCQ73v97znvv8AAHYPAAABVVUAAAAAABVVUADrK3czd3VHYPDMAbu7u7oAAHn4PDQAAAfsxnXXvXWZ33+99999egAb8AAB77W91VVVVX3waNNP499re6qqqqr74AAD32t7qqqqqvvgAAPfa3uqqqqq++AAA99re6qqqqruv7WswAAD9+73e+972qqqr74AAa99r9uqqqqq+18AAHvtb3VVVVVffAAAe+1vdVVVVV98AABn9r77d1ygAAAAAACqqoAAAVVVAAqqqADmYdY/W7u7ulMw999999vnvvvu7u7u6AAB+A4AVVVVVRVVVVVVX3wAAHvtb3VVVVVffAAAe+1vdVVVVV98AAB3X793vOd73tV3Xe973ve5r+1rMAAA/fu93vve5mZmZmdr74AAD9+/VzlWZmZmZlX3wAAHvtb3VVfa1XlVc4AABeq3uqqqqrnAAAPKt7qqqqq5wAADyre6qrve973ve5r+1r74AADf7Kh/lDJSyWSlTKTIjKspTFDKUVlJkoxKZRIzCisVTBUsisAoMhAQCSRgEBCAEwIZmfbve7aABzB+AAAAVVVAAAAAAAVVTo+gHhfq3d1VA96zPfQHu7u7u/3XWZ777777777VVV6AAAW22233sgaMgQjJAhB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mybJsmybJznQ5znnOc539TZNk2TZNk2TZNk2p3ve+u973zolCUJQlCUJQlCWTZOc5znnOc53xNk2TZNk2TQlCUJQne97673vfOiUJSFGyZCUJQlCUJQn3Td33u7vn0ShKEoShKEoShKEoT7Ad7313ve+fglCUJQlCUJQlCUJeZke/o++Ofn5kjQAAAAAAC22331bf0kt+AACSSSSSUGAQCALiqufCjnCjnCjZNk2TZNk2TZOc5znnOc53xKEoShKEoT2ZglGwZCUJu7vz3u7v0D1CUJQlCUJQlCUmybU5znOec5znfE2TZNk2TZNk2TZNk5znoc55znOd/E2TZNk2TZNk2TZNqc5znPOc5zvibJsmybJsmybJsmyc5znPOc5zvibX806ybJsmybJsmhKE3d3fe7u+fRKEoShKEoSybJsmyc5znPOc5zvibJsmybJsmybJsmyc5z0Oc85znPnvJoShKEoShKEoShKU7zw9fnZMzJZJ+yRz7XtaAAAAAAAW22++rbbQAANttttAb3ve9623iFCRQkUJFCRQkGxkJQlCUJu7u+93d8+iUJQmybJsmybJsmyc5znPOc5zvibJsmybJsmybJsmyc5znPOc5zvibJsmybJsmybJsmyc5znY55znOd+JsmybJsmyaEoShKTY3d3fm7u+IfRKEoSybJsmybE2Tc5znPfOc53xNk2TZNk2TZNk2TZOc5znnOc53xNk2TZNk2TZNk2TZOc5znnOc53xNk2TZNk2TZNk2TZOc5zsc85znO/E2TZNl/M6ybJsmybJtTnz76U9qYhlmTsknd39z3d3+AAAAAAALbbffVttoAFttttG8gQqqOqqjYDebtt9dYhQkUJFCRTZNk2TZNk2TnOc55znOd8TZNk2TZNk2TZNk2TnOc55znOd8TZNk2TZNk2TZNk2Twc5znfnOc53xNk2TZNk2TZKW3EMhPm7u+egPe7u+ehKEoShNk2TZNk2TanOc5zznOc74mybJsmybJsmybJsnOc5zznOc74mybJsmyNqbJsmyNqc5znPOc5zvibJsjamybJsmybJsng5znO/Oc5zvlGw386HWTQlCUJQlCUJ8+G7u+vYHz5u756FsmybJsmybJsmybU+/fS9VR0VQiqodyjIGQJa2MSSdNttttsAAAAAW2pIDoAAFttttDZJ+klyS/Lffd3dTZNk2TZNk2TZNk2TnOc5znOc4mybJsmybJsmybJsnOc5znOc5xNk2TZNk2Rv50hkJQlCdA/AN3m+bu79+iUJQmybJsmybJsmyffnpOc7578EkmKKCm2223IUJFCRQkUJFCRRsmybJsnOc5znOc5xNk2TZNk2TZNk2TYeDnOc75znOcfzLrJsmybJsmybJsmyfPB/N3fW+9379EoShKEoShKEoSk2Tv6Oc65zwc+c5z2mybJsmyKEoShKEoT8rLPz7qpxRSFYIapimqYL+BoquqmKlYWEMLVKYXFeefz5/P5/f38AAAAAAAW2220DczJu7u7u7ottt3MyDd3fYoLqpgBAoHe973vfzd8+iUJQlk2TZNk2TZNk5znOec5znfE0JQlCVsmQlCUJQlCbu7vvd3fPolCUJQlCUJQlCUJsng5znO/Oc5zvibJsmybJsmybJsmyefRznXO/OfBznPfabJsmybJsmybJsmyfdznrnPOc5zz6JQlCUJQlCUJQlGw5Cbu7vvd3fPolCUJQlCUJQlE2TZPBznOd+c5znfE2TZNk2TZNk2TZNk85znO/Oc5zg95Nk2TZNk2TZNk2Tan0c51znnPg5znvtNk2TZNk2TZNk2lsX3z83SVfxhbC0WopihVVVQKqoRVUWAuAwFmX3NSdNttsAAAAABbbbbQb6qqJJJJJJVUSRttvnORt3OgqqMgfQMEF73vr33ve/fPolCU7OQlCUJQlCUJQm7u773d3z6JQlCUmybJsmybJsng5znO/Oc5zvibJsmybJsmybJsmyec59++e/ve86JQlCUJQlCUJQlE2Tn0c51znzn0c536TZNk2TZEihIOkWRQkUJFHFJeTUkuyhIoSEoShKEoShKEoT0B3ve+e+97zolCUJQlCUJQlCUJQnrve98993798+iUJQlCUJQlCUTZNk+jnOuc85znO+JsmybJsmybJsmybJ95zrnPOc+jnPfqfzXWTZNk2TZNibSc8/fP3uivhmTkk9knu/f3NN/gAAAAAAC2222gAALbbaskiBgCrismH0qq5wo5wo5wo5wpsmybJ5znOd+c5znfE2TZNk2TZNk2TZNk9jnOc5885znfE2TZNk2TZNk2TZNk985znPnnPv3z6JQlCUJQ7mCUJQlCUJ8A3d3z3u70DfWCUJQlCUJQmybJsm1POc5zvznOc74mybJsmybJ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"
# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

# allegory interface layer begins here

import base64
import bz2
import json
import os
import sys
from os.path import expanduser

turnkey=False

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def save_snapshot(filename):
    j = json.dumps({"symbols": dictionary, \
                    "errors": errors, \
                    "stack": stack, \
                    "memory_contents": memory_values, \
                    "memory_types": memory_types, \
                    "memory_map": memory_map, \
                    "memory_sizes": memory_size, \
                    "hidden_slices": dictionary_hidden_slices })

    orig = open(__file__).read().split('\n')
    c = bz2.compress(bytes(j, 'utf-8'))

    with open(filename, 'w') as file:
        for line in orig:
            if line.startswith("stdlib"):
                file.write('stdlib="' + str(base64.b64encode(c)).replace("b'", "").replace("'", "") + '"')
            elif line.startswith("turnkey"):
                file.write("turnkey=False")
            else:
                file.write(line)
            file.write('\n')

    import stat
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)


def load_snapshot(filename):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices


    j = json.loads(open(filename, 'r').read())
    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']


def bootstrap(s):
    global dictionary, \
           errors, \
           stack, \
           memory_values, \
           memory_types, \
           memory_map, \
           memory_size, \
           dictionary_hidden_slices

    raw = base64.b64decode(bytes(s, 'utf-8'))
    u = bz2.decompress(raw)
    j = json.loads(u.decode())

    dictionary = j['symbols']
    errors = j['errors']
    stack = j['stack']
    memory_values = j['memory_contents']
    memory_types = j['memory_types']
    memory_map = j['memory_map']
    memory_size = j['memory_sizes']
    dictionary_hidden_slices = j['hidden_slices']

    xt = lookup_pointer('allegory.on-start')
    if xt != -1:
        interpret(xt, opcodes)

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def completer(text, state):
    options = [x for x in dictionary_names() if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def dump_dict():
    """display named items"""
    l = ''
    for w in dictionary_names():
        l = l + w + ' '
    sys.stdout.write(l)
    sys.stdout.write("\n")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def display_value():
    global stack
    i = len(stack) - 1
    t = stack_type_for(i)
    v = stack_value_for(i)
    if t == TYPE_NUMBER:
        sys.stdout.write(str(v))
    elif t == TYPE_CHARACTER:
        sys.stdout.write(str(chr(v)))
    elif t == TYPE_STRING:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_POINTER:
        sys.stdout.write('&' + str(v))
    elif t == TYPE_FLAG:
        if v == -1:
            sys.stdout.write("true")
        elif v == 0:
            sys.stdout.write("false")
        else:
            sys.stdout.write("malformed flag")
    elif t == TYPE_REMARK:
        sys.stdout.write(slice_to_string(v))
    elif t == TYPE_BYTECODE:
        sys.stdout.write('`' + str(v))
    elif t == TYPE_FUNCALL:
        sys.stdout.write('CALL: &' + str(v))
    else:
       sys.stdout.write("unknown type")

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def revert():
    global memory_values, memory_map, memory_types, dictionary
    memory_values = []
    memory_map = []
    memory_types = []
    dictionary = []
    prepare_slices()
    prepare_dictionary()
    stack_clear()
    i = 1
    while i < 8:
        if files[i] != 0:
            files[i].close()
            files[i] = 0
        i = i + 1

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ctags = []

def load_tagfile():
    global ctags
    if os.path.exists('tags'):
        with open('tags', 'r') as f:
            for line in f.readlines():
                ctags.append(line.split('\t'))


def tag(t):
    return '\t'.join(map(str,t))


def write_tagfile():
    if os.path.exists('tags'):
        with open('tags', 'w') as f:
            for l in ctags:
                f.write(tag(l) + '\n')


def determine_form(src):
    form = 0
    line = src.strip()
    if line.endswith('\' :'): form = 1
    if line.startswith('\'') and line.endswith(' .'): form = 2
    if line.startswith('\'') and line.endswith(' var'): form = 3
    if line.startswith('\'') and line.endswith(' var!'): form = 3
    if line.startswith('[ \'') and line.endswith(' ::'): form = 4
    return form


def extract_tags(src, form):
    tags = []
    tokens = src.strip().split(' ')
    if form == 1 or form == 3:
        token = tokens[-2:][0:1][0]
        tags.append(token[1:-1])
    elif form == 2:
        token = tokens[0:1][0]
        tags.append(token[1:-1])
    elif form == 4:
        token = tokens[1:-2]
        for t in token:
            if t != '':
                tags.append(t[1:-1])
    return tags


def get_tags_in(fn):
    tags = []
    with open(fn, 'r') as file:
        lines = file.readlines()
        i = 1
        for l in lines:
            form = determine_form(l)
            if form > 0:
                for tag in extract_tags(l, form):
                    tags.append((tag, fn, i))
            i = i + 1
    return tags


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

files = []

def opcodes(slice, offset, opcode):
    global dictionary_warnings
    if opcode == 2000:
        dictionary_warnings = True
    if opcode == 2001:
        dictionary_warnings = False
    if opcode == 200:
        stack_push(string_to_slice(expanduser('~')), TYPE_STRING)
    elif opcode == 201:
        slot = 0
        i = 1
        while i < (len(files) - 1):
            if files[i] == 0:
                slot = i
            i = i + 1
        mode = slice_to_string(stack_pop())
        name = slice_to_string(stack_pop())
        if slot != 0:
            try:
                files[int(slot)] = open(name, mode)
            except:
                files[int(slot)] = -1
                report('A10: Unable to open file named ' + name)
        stack_push(slot, TYPE_NUMBER)
    elif opcode == 202:
        slot = int(stack_pop())
        files[slot].close()
        files[slot] = 0
    elif opcode == 203:
        slot = int(stack_pop())
        try:
            stack_push(ord(files[slot].read(1)), TYPE_CHARACTER)
        except:
            report('Non-ASCII characters detected, aborting file input')
            abort_run(opcode, offset)
    elif opcode == 204:
        slot = int(stack_pop())
        files[slot].write(chr(int(stack_pop())))
    elif opcode == 205:
        slot = int(stack_pop())
        stack_push(files[slot].tell(), TYPE_NUMBER)
    elif opcode == 206:
        slot = int(stack_pop())
        pos = int(stack_pop())
        stack_push(files[slot].seek(pos, 0), TYPE_NUMBER)
    elif opcode == 207:
        slot = int(stack_pop())
        at = files[slot].tell()
        files[slot].seek(0, 2) # SEEK_END
        stack_push(files[slot].tell(), TYPE_NUMBER)
        files[slot].seek(at, 0) # SEEK_SET
    elif opcode == 208:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            os.remove(name)
    elif opcode == 209:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            stack_push(-1, TYPE_FLAG)
        else:
            stack_push(0, TYPE_FLAG)
    elif opcode == 226:
        s = request_slice()
        i = 0
        while i < len(sys.argv):
            store(string_to_slice(sys.argv[i]), s, i, TYPE_STRING)
            i = i + 1
        stack_push(s, TYPE_POINTER)
    elif opcode == 227:
        from subprocess import call
        s = slice_to_string(stack_pop())
        n = call(s, shell = True)
        stack_push(n, TYPE_NUMBER)
    elif opcode == 300:
        import time
        stack_push(time.time(), TYPE_NUMBER)
    elif opcode == 4000:
        stack_push(len(sys.argv) - 2, TYPE_NUMBER)
    elif opcode == 4001:
        n = int(stack_pop())
        stack_push(string_to_slice(sys.argv[n + 2]), TYPE_STRING)
    elif opcode == 5000:
        key = slice_to_string(stack_pop())
        value = form.getvalue(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 5001:
        key = slice_to_string(stack_pop())
        value = os.getenv(key, "(no)")
        stack_push(string_to_slice(value), TYPE_STRING)
    elif opcode == 6000:
        display_value()
        stack_pop()
        sys.stdout.flush()
    elif opcode == 9001:
        xt = lookup_pointer('allegory.on-end')
        if xt != -1:
            interpret(xt, opcodes)
        write_tagfile()
        exit()
    elif opcode == 9002:
        dump_dict()
    elif opcode == 9003:
        name = slice_to_string(stack_pop())
        load_file(name)
        global ctags
        ctags = ctags + get_tags_in(name)
        n = []
        for tag in ctags:
            if not tag in n:
                n.append(tag)
        ctags = n
    elif opcode == 9004:
        save_snapshot(slice_to_string(stack_pop()))
    elif opcode == 9005:
        name = slice_to_string(stack_pop())
        if os.path.exists(name):
            load_snapshot(name)
        else:
            report('A20: ' + name + ' not found')
    elif opcode == 9006:
        revert()
        bootstrap(stdlib)
    elif opcode == 9007:
        s = slice_to_string(stack_pop())
        match = False
        for tag in ctags:
            if tag[0] == s and not match:
                stack_push(string_to_slice(tag[1]), TYPE_STRING)
                stack_push(float(tag[2]), TYPE_NUMBER)
                match = True
        if not match:
            stack_push(string_to_slice('(no source found)'), TYPE_STRING)
    return offset

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
ignore_depth = 0

def allegory_evaluate(src):
    global ignore_depth
    if src == "+ignore":
        ignore_depth = ignore_depth + 1
    elif src == "-ignore":
        ignore_depth = ignore_depth - 1
    elif ignore_depth <= 0:
        interpret(compile(src), opcodes)
    if ignore_depth < 0:
        ignore_depth = 0


def extract_from_markdown(name):
    v = []
    with open(name) as f:
        v = f.readlines()
    s = []
    fence = False
    for l in v:
        clean = l.strip()
        if l.startswith('    '): s.append(l[4:])
        elif fence == True and clean != '````':
            s.append(l)
        elif clean == '````' and fence == True:
            fence = False
        elif clean == '````' and fence == False:
            fence = True
    return s


def load_file(name):
    global should_abort
    should_abort = False
    if os.path.exists(name):
        if name.endswith('.md'): lines = condense_lines(extract_from_markdown(name))
        else: lines = condense_lines(open(name).readlines())
        for l in lines:
#            try:
                if l != "#!/usr/bin/env allegory" and should_abort == False:
                    allegory_evaluate(l)
#            except:
#                e = sys.exc_info()[0]
#                if e == SystemExit: exit()
#                pass
        for e in errors:
            sys.stdout.write('IN: ' + name + ', ' + e + '\n')
        clear_errors()
    else:
        report('A10: Unable to open file named ' + name)
        for e in errors:
            sys.stdout.write(e + '\n')
        clear_errors()
        should_abort = True


def evaluate(s):
    try:
        interpret(compile(s))
    except:
        sys.stdout.write("\n")
        pass


def get_input():
    done = False
    s = ''
    s = input("\nok\n")
    while not done:
        if s.endswith(' \\'):
            s = s[:-2].strip() + ' '
            s = s + input()
        else:
            braces = 0
            tokens = s.strip().split(' ')
            for t in tokens:
                if t == '[': braces = braces + 1
                if t == ']': braces = braces - 1
            if braces == 0:
                done = True
            else:
                s = s.strip() + ' '
                s = s + input()
    return s


# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def scripting():
    bootstrap(stdlib)
    source = sys.argv[1]
    if not os.path.exists(source):
        sys.exit('ERROR: source file "%s" was not found!' % source)
    load_file(source)
    xt = lookup_pointer('allegory.on-end')
    if xt != -1:
        interpret(xt, opcodes)
    write_tagfile()


def interactive():
    global turnkey
    try:
        import readline
        readline.set_completer(completer)
        readline.parse_and_bind("tab: complete")
    except (ImportError, AttributeError):
        pass

    bootstrap(stdlib)

    if turnkey:
        if os.path.exists('on_startup.md'):
            load_file('on_startup.md')
        elif os.path.exists('on_startup.p'):
            load_file('on_startup.p')
        elif os.path.exists(expanduser('~') + '/on_startup.md'):
            load_file(expanduser('~') + '/on_startup.md')
        elif os.path.exists(expanduser('~') + '/on_startup.p'):
            load_file(expanduser('~') + '/on_startup.p')

    while True:
        try:
            src = get_input()
        except:
            sys.stdout.write("\n")
            exit()

        if len(src) >= 1:
            try:
                allegory_evaluate(src)
            except KeyboardInterrupt:
                sys.stdout.write("\n")
                pass

        for e in errors:
            print(e)

        clear_errors()
        sys.stdout.flush()

# -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

if __name__ == '__main__':
    for i in range(0, 32):
        files.append(0)

    prepare_slices()
    prepare_dictionary()

    load_tagfile()

    if len(sys.argv) < 2:
        interactive()
    else:
        scripting()

    sys.stdout.flush()


